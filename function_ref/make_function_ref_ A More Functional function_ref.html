<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>make_function_ref: A More Functional function_ref</title>
  <meta name="description" content="make_function_ref: A More Functional function_ref">
  <meta name="author" content="Jarrad Waterloo">
  <style>
    h1
	{
	  text-align : center;
	}
	.code
	{
	  background-color: AliceBlue;
	}
	table.simple
	{
		border: 1px solid black;
		border-collapse: collapse;
	}
	table.simple > thead > tr > th
	{
		border: 1px solid black;
	}
	table.simple > tbody > tr > td
	{
		border: 1px solid black;
	}
	.problem
	{
		font-weight : bold;
		color : red;
	}
  </style>
</head>
<body>
<h1>make_function_ref: A More Functional function_ref</h1>
<table style="width:100%">
<tr>
<td>&nbsp;</td>
<td style="width:60ex">
  <table>
  <tr>
  <td><b>Document #:</b></td><td>P2472R1</td>
  </tr>
  <tr>
  <td><b>Date:</b></td><td>2021-12-06</td>
  </tr>
  <tr>
  <td><b>Project:</b></td><td>Programming Language C++</td>
  </tr>
  <tr>
  <td><b>Audience:</b></td><td>Library Evolution Working Group (LEWG)</td>
  </tr>
  <tr>
  <td><b>Reply-to:</b></td><td>Jarrad J. Waterloo<br/>&lt;<a href="mailto:descender76@gmail.com">descender76@gmail.com</a>&gt;</td>
  </tr>
  </table>
</td>
</tr>
</table>
<h2>Contents</h2>
<h3><a href="#abstract">1&nbsp;&nbsp;Abstract</a></h3>
<h3><a href="#overview">2&nbsp;&nbsp;Overview</a></h3>
<h3><a href="#motivating-examples">3&nbsp;&nbsp;Motivating examples</a></h3>
<h3><a href="#solution">4&nbsp;&nbsp;Solution</a></h3>
<h3><a href="#ftm">5&nbsp;&nbsp;Feature test macro</a></h3>
<h3><a href="#implementation">6&nbsp;&nbsp;Example implementation</a></h3>
<h3><a href="#acknowledgments">7&nbsp;&nbsp;Acknowledgments</a></h3>
<h3><a href="#alternative">8&nbsp;&nbsp;Annex: alternative design decisions</a></h3>
<h4><a href="#auto">8.1&nbsp;&nbsp;&nbsp;auto</a></h4>
<h4><a href="#general-purpose-callable-library">8.2&nbsp;&nbsp;&nbsp;General Purpose Callable Library</a></h4>
<h3><a href="#references">9&nbsp;&nbsp;References</a></h3>
<h2 id="abstract">Abstract</h2>
<!--
<p>This paper proposes the addition of two make_function_ref functions to the current <a href="#reference-p0792r5">function_ref</a> proposal to better handle "member function with type erasure" and "free function with type erasure" usecases.</p>
<p>The current <a href="#reference-p0792r5">function_ref</a> proposal is closely modeled as a drop in replacement for std::function. It is assumed that it works the same but is referenced based instead of copy based. As such the current proposal provides little direction as to how it may be constructed and used safely. While std::function is more intuitive, function_ref is less so. Further with the change to reference based, function_ref is capable of so much more than what is provided, since it being modeled after std::function which was designed with copying in mind.</p>
-->
<p>I propose to make <a href="#reference-p0792r5">function_ref</a> easier and safer to use with pointer-to-member-functions by adding a std::make_function_ref factory function. Also the pointer-to-free-function and pointer-to-member-function cases should be expanded to easily and safely include type erased state just like functors and capturing lambdas has.</p>
<h2 id="overview">Overview</h2>
<!--
<p>"function_ref" <b>ONLY</b> has <b>ONE</b>, non copy, constructor which takes a const reference to a functor. The "erased_object/obj_" points to the functor and the "erased_function/callback_" points to a binding function that calls the functor's call operator receiving not only the operator parameters but also the "erased_object/obj_". "function_ref" can be created by binding a functor/stateful lambda, a C function pointer/stateless lambda and a C++ member function pointer. There are important differences between these 3 use cases. The functor/stateful lambda use case supports type erased state while the C function pointer/stateless lambda and a C++ member function pointer use cases do not. In order to type erase one parameter of a free function or the this parameter of a member function a functor/stateful lambda must be created to hold the reference to the desired state. This exposes some of the limitations of the current function_ref's proposal. "std::array" is to the C array AS function_ref is to the C function pointer. function_ref is tedious when it comes to being to assign functional things of ~exact function signature while C function pointers are not. Usage of NON typed erased [member] functions is easier to construct than using type erased [member] functions. Type erased [member] functions is generally more common and definitely more useful than their NON type erased counterparts.</p>
<p>Consider for a moment the use case of type erased member functions. This type of single function runtime polymorphism is found throughout the OOP programming world. For instance, in the .NET world, such as C#, has <a href="#reference-delegate">single and multi cast delegates</a>. Embarcadero C++'s has it via their<a href="#reference-closure">__closure</a>. This has also been peddled in the standard C++ world via articles such as <a href="#reference-fastest">Member Function Pointers and the Fastest Possible C++ Delegates</a>, <a href="#reference-fast">The Impossibly Fast C++ Delegate</a> and <a href="#reference-impossibly">Impossibly fast delegate in C++11</a>. One thing all of these implementations have in common is the ability to easily create these delegates via a constructor with two parameters; the instance to be type erased and the member function pointer.</p>
<p>Similarly too, the use case of type erased functions has been instrumental in the functional programming world for decades in C and other programming languages. The utility of simplifying the construction of these common use cases are demonstrated below.</p>
-->
<p>In order to be able to identify such areas of improvement, we need to look at the <a href="#reference-github">reference implementation</a> for function_ref. This also requires that we, momentarily, add one constructor that provides direct access to its two pointers.</p>
<h3 id="the-given">The given</h3>
<!-- make_function_ref-constructor-only.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">F</font><font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">;</font>

<i><font color="#9A1900">/// Specializations for function types.</font></i>
<b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">R</font><font color="#990000">,</font> <b><font color="#0000FF">class</font></b><font color="#990000">...</font> Args<font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">&lt;</font><b><font color="#000000">R</font></b><font color="#990000">(</font>Args<font color="#990000">...)&gt;</font> <font color="#FF0000">{</font>
<b><font color="#0000FF">public</font></b><font color="#990000">:</font>
  <b><font color="#000000">function_ref</font></b><font color="#990000">(</font><font color="#009900">void</font><font color="#990000">*</font> obj_<font color="#990000">,</font> <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font>Args<font color="#990000">...))</font> <b><font color="#0000FF">noexcept</font></b> <font color="#990000">:</font> obj_<font color="#FF0000">{</font>obj_<font color="#FF0000">}</font><font color="#990000">,</font> callback_<font color="#FF0000">{</font>callback_<font color="#FF0000">}</font> <font color="#FF0000">{}</font>
<b><font color="#0000FF">private</font></b><font color="#990000">:</font>
  <font color="#009900">void</font> <font color="#990000">*</font>obj_ <font color="#990000">=</font> nullptr<font color="#990000">;</font>
  <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font> <font color="#990000">*,</font> Args<font color="#990000">...)</font> <font color="#990000">=</font> nullptr<font color="#990000">;</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">R</font><font color="#990000">,</font> <b><font color="#0000FF">class</font></b><font color="#990000">...</font> Args<font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">&lt;</font><b><font color="#000000">R</font></b><font color="#990000">(</font>Args<font color="#990000">...)</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">&gt;</font> <font color="#FF0000">{</font>
<b><font color="#0000FF">public</font></b><font color="#990000">:</font>
  <b><font color="#000000">function_ref</font></b><font color="#990000">(</font><font color="#009900">void</font><font color="#990000">*</font> obj_<font color="#990000">,</font> <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font>Args<font color="#990000">...))</font> <b><font color="#0000FF">noexcept</font></b> <font color="#990000">:</font> obj_<font color="#FF0000">{</font>obj_<font color="#FF0000">}</font><font color="#990000">,</font> callback_<font color="#FF0000">{</font>callback_<font color="#FF0000">}</font> <font color="#FF0000">{}</font>
<b><font color="#0000FF">private</font></b><font color="#990000">:</font>
  <font color="#009900">void</font> <font color="#990000">*</font>obj_ <font color="#990000">=</font> nullptr<font color="#990000">;</font>
  <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font> <font color="#990000">*,</font> Args<font color="#990000">...)</font> <b><font color="#0000FF">noexcept</font></b> <font color="#990000">=</font> nullptr<font color="#990000">;</font>
<font color="#FF0000">}</font><font color="#990000">;</font>
</tt></pre>

</div>
<p>All examples unless stated otherwise were compiled on <a href="https://www.godbolt.org/">godbolt.org</a> using "x86-64 clang (trunk)" with "-std=c++20 -O2" in order to identify dangling.</p>
<h2 id="motivating-examples">Motivating examples</h2>
<h3 id="function_ref-construction-usage">function_ref construction and usage</h3>
<h3 id="function_ref-stateless">free function and member function without type erasure use cases</h3>
<!-- function_ref-immediate-dangle.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><i><font color="#9A1900">//#include &lt;https://raw.githubusercontent.com/TartanLlama/function_ref/master/include/tl/function_ref.hpp&gt;</font></i>
<b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;https://raw.githubusercontent.com/descender76/cpp_proposals/main/function_ref/function_ref_prime.hpp&gt;</font>

<b><font color="#0000FF">struct</font></b> <font color="#008080">bar</font> <font color="#FF0000">{</font>
    <font color="#009900">void</font> <b><font color="#000000">baz</font></b><font color="#990000">()</font><font color="#FF0000">{}</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<font color="#009900">void</font> <b><font color="#000000">foo</font></b><font color="#990000">(</font>bar<font color="#990000">)</font> <font color="#FF0000">{</font>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// member function immediately dangle</font></i>
<font color="#009900">void</font> <b><font color="#000000">function_ref_member_function_dangle</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> <font color="#990000">&amp;</font>bar<font color="#990000">::</font>baz<font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>  <i><font color="#9A1900">// UB, fr3 is already dangling</font></i>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// free function does not dangle</font></i>
<font color="#009900">void</font> <b><font color="#000000">function_ref_free_function</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> foo<font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// free function dangle</font></i>
<font color="#009900">void</font> <b><font color="#000000">function_ref_free_function_dangle</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> <font color="#990000">&amp;</font>foo<font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// member function does not dangle</font></i>
<font color="#009900">void</font> <b><font color="#000000">function_member_function_dangle</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    std<font color="#990000">::</font><font color="#008080">function&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> <font color="#990000">&amp;</font>bar<font color="#990000">::</font>baz<font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// free function does not dangle</font></i>
<font color="#009900">void</font> <b><font color="#000000">function_free_function</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    std<font color="#990000">::</font><font color="#008080">function&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> foo<font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// free function does not dangle</font></i>
<font color="#009900">void</font> <b><font color="#000000">function_free_function_dangle</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    std<font color="#990000">::</font><font color="#008080">function&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> <font color="#990000">&amp;</font>foo<font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
<font color="#FF0000">}</font>

<font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    <b><font color="#0000FF">return</font></b> <font color="#993399">42</font><font color="#990000">;</font>
<font color="#FF0000">}</font></tt></pre>

</div>
<p>There are two things to note from the previous example. First, std::function works as expected in all three scenarios. The comparable function_ref has immediate dangling in two of the three. Second, when you compare function_ref to itself, there is a scenario where free function works but member function doesn't. This treats object oriented programming with less support than functional programming. Its been said that this is the incorrect usage of function_ref, in effect blaming the user instead of the specification and implementation. Those that believe such may give the following example as proof as it is ok to standardize something that can immediately dangle.</p>
<!-- string_view-immediate-dangle.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>std<font color="#990000">::</font><font color="#008080">string_view</font> sv <font color="#990000">=</font> <font color="#FF0000">"hello world"</font>s<font color="#990000">;</font>  <i><font color="#9A1900">// immediately dangling</font></i></tt></pre>

</div>
<p>While I normally would agree with such sentiment, in this scenario I whole heartedly disagree. Dangling occurs when you still have a reference to state that has gone out of scope, no longer exists. In this string_view example, it is clear that sv is a reference and ""s is state. It is totally unclear in the case of function_ref initialization. Dangling is not what the end user is intending on doing when a function is assigned whether free or member. Functions are stateless and also global, so they don't go out of scope. This implementation stores a free function pointer as the void* state of function_ref and because a member function pointer is larger than void* it is treated just like a capturing lambda or functor of size greater than a void*. In essence, implementation details are bleeding through function_ref's public interface and effecting how users are to use function_ref. The current function_ref specification is currently silent on how implementations should behave and how end users should consume in light of its differences with std::function.</p>
<p>Another example given by the current proponents of function_ref is how the users of function_ref should fix the dangling.</p>
<!-- function_ref-dangling-corrected-by-user.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><i><font color="#9A1900">//#include &lt;https://raw.githubusercontent.com/TartanLlama/function_ref/master/include/tl/function_ref.hpp&gt;</font></i>
<b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;https://raw.githubusercontent.com/descender76/cpp_proposals/main/function_ref/function_ref_prime.hpp&gt;</font>

<b><font color="#0000FF">struct</font></b> <font color="#008080">bar</font> <font color="#FF0000">{</font>
    <font color="#009900">void</font> <b><font color="#000000">baz</font></b><font color="#990000">()</font><font color="#FF0000">{}</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<font color="#009900">void</font> <b><font color="#000000">foo</font></b><font color="#990000">(</font>bar<font color="#990000">)</font> <font color="#FF0000">{</font>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// member function immediately dangle WORKAROUND</font></i>
<font color="#009900">void</font> <b><font color="#000000">function_ref_member_function_workaround</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    <b><font color="#0000FF">auto</font></b> temp <font color="#990000">=</font> <font color="#990000">&amp;</font>bar<font color="#990000">::</font>baz<font color="#990000">;</font><i><font color="#9A1900">// WORKAROUND</font></i>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> temp<font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>  <i><font color="#9A1900">// UB, fr3 is NOT already dangling</font></i>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// free function dangle WORKAROUND</font></i>
<font color="#009900">void</font> <b><font color="#000000">function_ref_free_function_workaround</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    <b><font color="#0000FF">auto</font></b> temp <font color="#990000">=</font> <font color="#990000">&amp;</font>foo<font color="#990000">;</font><i><font color="#9A1900">// WORKAROUND</font></i>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> temp<font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
<font color="#FF0000">}</font>

<font color="#009900">void</font> <b><font color="#000000">correct_usage_of_current_function_ref_some_work</font></b><font color="#990000">(</font>tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt; fr1, tl::function_ref&lt;void(bar)&gt;</font> fr2<font color="#990000">)</font> <font color="#FF0000">{</font>
    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr1</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr2</font></b><font color="#990000">(</font>b<font color="#990000">);</font>    
<font color="#FF0000">}</font>

<font color="#009900">void</font> <b><font color="#000000">correct_usage_of_current_function_ref</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    <b><font color="#000000">correct_usage_of_current_function_ref_some_work</font></b><font color="#990000">(&amp;</font>foo<font color="#990000">,</font> <font color="#990000">&amp;</font>bar<font color="#990000">::</font>baz<font color="#990000">);</font>
<font color="#FF0000">}</font>

<font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    <b><font color="#0000FF">return</font></b> <font color="#993399">42</font><font color="#990000">;</font>
<font color="#FF0000">}</font></tt></pre>

</div>
<p>Where is this usage specified in the specification? Proponents advocate for not even messing with the WORKAROUND, i.e. sort of how one currently deals with dangling today, and that the correct usage is for just the initializing parameter to be passed directly to the function parameter in question. I would argue that we should still be able to initialize first because I may provide the same function_ref instantiation to multiple parameters across multiple function calls. Otherwise, duplicating an exact same lambda, in more complicated scenarios, would increase verbosity and violating in programming the one definition rule or don't repeat yourself. This usage is also plagued with the superfluous workaround line. Why initialize with 2 lines of code when it should just be one! Again, it is not like std::function or how we initialize in C++. Why force end users to work around dangling needlessly when the library implementation is more than capable of handling this? By fixing these trivial dangling noise, we leave the remaining dangling cases to be as clear as the std::string_view example. So, how do we fix some of this dangling in the implementation!</p>
<h3 id="reference-power">the true power of the reference side</h3>
<p>Given the new constructor mentioned in the "<a href="#overview">Overview</a>" we can construct an example that does not dangle.</p>
<!-- function_ref-dangling-corrected-by-user2.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><i><font color="#9A1900">//#include &lt;https://raw.githubusercontent.com/TartanLlama/function_ref/master/include/tl/function_ref.hpp&gt;</font></i>
<b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;https://raw.githubusercontent.com/descender76/cpp_proposals/main/function_ref/function_ref_prime.hpp&gt;</font>

<b><font color="#0000FF">struct</font></b> <font color="#008080">bar</font> <font color="#FF0000">{</font>
    <font color="#009900">void</font> <b><font color="#000000">baz</font></b><font color="#990000">()</font><font color="#FF0000">{}</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<font color="#009900">void</font> <b><font color="#000000">foo</font></b><font color="#990000">(</font>bar<font color="#990000">)</font> <font color="#FF0000">{</font>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// member function immediately dangle</font></i>
<font color="#009900">void</font> <b><font color="#000000">function_ref_member_function_dangling</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> <font color="#990000">&amp;</font>bar<font color="#990000">::</font>baz<font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>  <i><font color="#9A1900">// UB, fr3 is already dangling</font></i>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// free function immediately dangle</font></i>
<font color="#009900">void</font> <b><font color="#000000">function_ref_free_function_dangling</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> <font color="#990000">&amp;</font>foo<font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>  <i><font color="#9A1900">// UB, fr3 is already dangling</font></i>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// member function without dangle via new constructor</font></i>
<font color="#009900">void</font> <b><font color="#000000">function_ref_member_function_new</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> <font color="#FF0000">{</font>nullptr<font color="#990000">,</font> <font color="#990000">[](</font><font color="#009900">void</font><font color="#990000">*,</font> <font color="#008080">bar</font> b<font color="#990000">)</font><font color="#FF0000">{</font>b<font color="#990000">.</font><b><font color="#000000">baz</font></b><font color="#990000">();</font><font color="#FF0000">}}</font><font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>  <i><font color="#9A1900">// UB, fr3 is NOT already dangling</font></i>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// member function without dangle via new constructor</font></i>
<font color="#009900">void</font> <b><font color="#000000">function_ref_free_function_new</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> <font color="#FF0000">{</font>nullptr<font color="#990000">,</font> <font color="#990000">[](</font><font color="#009900">void</font><font color="#990000">*,</font> <font color="#008080">bar</font> b<font color="#990000">)</font><font color="#FF0000">{</font><b><font color="#000000">foo</font></b><font color="#990000">(</font>b<font color="#990000">);</font><font color="#FF0000">}}</font><font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>  <i><font color="#9A1900">// UB, fr3 is NOT already dangling</font></i>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// member function without dangle via stateless lambda</font></i>
<font color="#009900">void</font> <b><font color="#000000">function_ref_member_function_lambda</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> <font color="#990000">[](</font><font color="#008080">bar</font> b<font color="#990000">)</font><font color="#FF0000">{</font>b<font color="#990000">.</font><b><font color="#000000">baz</font></b><font color="#990000">();</font><font color="#FF0000">}</font><font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>  <i><font color="#9A1900">// UB, fr3 is NOT already dangling</font></i>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// free function without dangle via stateless lambda</font></i>
<font color="#009900">void</font> <b><font color="#000000">function_ref_free_function_lambda</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> <font color="#990000">[](</font><font color="#008080">bar</font> b<font color="#990000">)</font><font color="#FF0000">{</font><b><font color="#000000">foo</font></b><font color="#990000">(</font>b<font color="#990000">);</font><font color="#FF0000">}</font><font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>  <i><font color="#9A1900">// UB, fr3 is NOT already dangling</font></i>
<font color="#FF0000">}</font>

<font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    <b><font color="#0000FF">return</font></b> <font color="#993399">42</font><font color="#990000">;</font>
<font color="#FF0000">}</font></tt></pre>

</div>
<p>This set of examples shows how free function and member function without type erasure use cases can be handled without any dangling and without the syntax of having to put function_ref initialization parameter on a seperate temporary line. The pair of examples that uses the new constructor is clear that their is no dangling because their is no state is by the nullptr and the lambda used doesn't capture i.e. stateless. Similarly, the lambda examples that uses the current function_ref constructor is similarly non capturing stateless. The problem with these two solutions is the lack of clarity because we can't simple assign a function with a known compatible signature. This means we have [], (), forwarded aparmeters and possibly return statement. The new constructor examples are also not type safe though in a stateless scenario that is a little less of an issue. However, by nailing down the specification and providing the new constructor, we can do much better.</p>
<!-- make_function_ref-stateless.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><i><font color="#9A1900">//#include &lt;https://raw.githubusercontent.com/TartanLlama/function_ref/master/include/tl/function_ref.hpp&gt;</font></i>
<b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;https://raw.githubusercontent.com/descender76/cpp_proposals/main/function_ref/function_ref_prime.hpp&gt;</font>

<b><font color="#0000FF">struct</font></b> <font color="#008080">bar</font> <font color="#FF0000">{</font>
    <font color="#009900">void</font> <b><font color="#000000">baz</font></b><font color="#990000">()</font><font color="#FF0000">{}</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<font color="#009900">void</font> <b><font color="#000000">foo</font></b><font color="#990000">(</font>bar<font color="#990000">&amp;)</font> <font color="#FF0000">{</font>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// side by side examples</font></i>
<font color="#009900">void</font> <b><font color="#000000">examples</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar&amp;)&gt;</font> fr1 <font color="#990000">=</font> <font color="#FF0000">{</font>nullptr<font color="#990000">,</font> <font color="#990000">[](</font><font color="#009900">void</font><font color="#990000">*,</font> bar<font color="#990000">&amp;</font> b<font color="#990000">)</font><font color="#FF0000">{</font>b<font color="#990000">.</font><b><font color="#000000">baz</font></b><font color="#990000">();</font><font color="#FF0000">}}</font><font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar&amp;)&gt;</font> fr2 <font color="#990000">=</font> <font color="#FF0000">{</font>nullptr<font color="#990000">,</font> <font color="#990000">[](</font><font color="#009900">void</font><font color="#990000">*,</font> bar<font color="#990000">&amp;</font> b<font color="#990000">)</font><font color="#FF0000">{</font><b><font color="#000000">foo</font></b><font color="#990000">(</font>b<font color="#990000">);</font><font color="#FF0000">}}</font><font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar&amp;)&gt;</font> fr3 <font color="#990000">=</font> <font color="#990000">[](</font>bar<font color="#990000">&amp;</font> b<font color="#990000">)</font><font color="#FF0000">{</font>b<font color="#990000">.</font><b><font color="#000000">baz</font></b><font color="#990000">();</font><font color="#FF0000">}</font><font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar&amp;)&gt;</font> fr4 <font color="#990000">=</font> <font color="#990000">[](</font>bar<font color="#990000">&amp;</font> b<font color="#990000">)</font><font color="#FF0000">{</font><b><font color="#000000">foo</font></b><font color="#990000">(</font>b<font color="#990000">);</font><font color="#FF0000">}</font><font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar&amp;)&gt;</font> fr5 <font color="#990000">=</font> tl<font color="#990000">::</font>make_function_ref<font color="#990000">&lt;</font>foo<font color="#990000">&gt;();</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar&amp;)&gt;</font> fr6 <font color="#990000">=</font> tl<font color="#990000">::</font>make_function_ref<font color="#990000">&lt;&amp;</font>foo<font color="#990000">&gt;();</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar&amp;)&gt;</font> fr7 <font color="#990000">=</font> tl<font color="#990000">::</font>make_function_ref<font color="#990000">&lt;&amp;</font>bar<font color="#990000">::</font>baz<font color="#990000">&gt;();</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr1</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr2</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr4</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr5</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr6</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr7</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
<font color="#FF0000">}</font>

<font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    <b><font color="#0000FF">return</font></b> <font color="#993399">42</font><font color="#990000">;</font>
<font color="#FF0000">}</font></tt></pre>

</div>
<p>These make_function_ref examples provides the best of both worlds. No dangling for member and free functions without type erasure and a reasonably concise syntax that explicitly states what the user intends to do.</p>
<h3 id="function_ref-construction-missing">the missing function_ref construction use cases</h3>
<p>Adding the new constructor, mentioned in the "<a href="#overview">Overview</a>", makes the implementation of function_ref capable of so much more functionality then is currently available. The current function_ref implentation only type erases state for callables such as capturing lambdas but what if your functions or member functions could benefit from type erasure. Instead of making these latter two use cases easy, current users have to use a lambda even if there were no changes in their callable parameters. This too can be improved.</p>
<h3 id="function_ref-stateful">free function and member function with type erasure use cases</h3>
<!-- make_function_ref-stateful.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><i><font color="#9A1900">//#include &lt;https://raw.githubusercontent.com/TartanLlama/function_ref/master/include/tl/function_ref.hpp&gt;</font></i>
<b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;https://raw.githubusercontent.com/descender76/cpp_proposals/main/function_ref/function_ref_prime.hpp&gt;</font>

<b><font color="#0000FF">struct</font></b> <font color="#008080">bar</font> <font color="#FF0000">{</font>
    <font color="#009900">void</font> <b><font color="#000000">baz</font></b><font color="#990000">()</font><font color="#FF0000">{}</font>
    <font color="#009900">void</font> <b><font color="#0000FF">operator</font></b><font color="#990000">()()</font><font color="#FF0000">{}</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<font color="#009900">void</font> <b><font color="#000000">foo</font></b><font color="#990000">(</font>bar<font color="#990000">&amp;)</font> <font color="#FF0000">{</font>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// side by side examples</font></i>
<font color="#009900">void</font> <b><font color="#000000">examples</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    <font color="#008080">bar</font> b<font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr1 <font color="#990000">=</font> <font color="#990000">[&amp;</font>b<font color="#990000">]()</font><font color="#FF0000">{</font>b<font color="#990000">.</font><b><font color="#000000">baz</font></b><font color="#990000">();</font><font color="#FF0000">}</font><font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr2 <font color="#990000">=</font> <font color="#990000">[&amp;</font>b<font color="#990000">]()</font><font color="#FF0000">{</font><b><font color="#000000">foo</font></b><font color="#990000">(</font>b<font color="#990000">);</font><font color="#FF0000">}</font><font color="#990000">;</font>
    <i><font color="#9A1900">// using the new constructor</font></i>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr3 <font color="#990000">=</font> <font color="#FF0000">{</font><font color="#990000">&amp;</font>b<font color="#990000">,</font> <font color="#990000">[](</font><font color="#009900">void</font><font color="#990000">*</font> obj<font color="#990000">)</font><font color="#FF0000">{</font><b><font color="#0000FF">static_cast</font></b><font color="#990000">&lt;</font>bar<font color="#990000">*&gt;(</font>obj<font color="#990000">)-&gt;</font><b><font color="#000000">baz</font></b><font color="#990000">();</font><font color="#FF0000">}}</font><font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr4 <font color="#990000">=</font> <font color="#FF0000">{</font><font color="#990000">&amp;</font>b<font color="#990000">,</font> <font color="#990000">[](</font><font color="#009900">void</font><font color="#990000">*</font> obj<font color="#990000">)</font><font color="#FF0000">{</font><b><font color="#000000">foo</font></b><font color="#990000">(*</font><b><font color="#0000FF">static_cast</font></b><font color="#990000">&lt;</font>bar<font color="#990000">*&gt;(</font>obj<font color="#990000">));</font><font color="#FF0000">}}</font><font color="#990000">;</font>
    <i><font color="#9A1900">// using make_function_ref which uses new constructor</font></i>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr5 <font color="#990000">=</font> tl<font color="#990000">::</font>make_function_ref<font color="#990000">&lt;</font>foo<font color="#990000">&gt;(</font>b<font color="#990000">);</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr6 <font color="#990000">=</font> tl<font color="#990000">::</font>make_function_ref<font color="#990000">&lt;&amp;</font>foo<font color="#990000">&gt;(</font>b<font color="#990000">);</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr7 <font color="#990000">=</font> tl<font color="#990000">::</font>make_function_ref<font color="#990000">&lt;&amp;</font>bar<font color="#990000">::</font>baz<font color="#990000">&gt;(</font>b<font color="#990000">);</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr8 <font color="#990000">=</font> tl<font color="#990000">::</font>make_function_ref<font color="#990000">&lt;&amp;</font>bar<font color="#990000">::</font><b><font color="#0000FF">operator</font></b><font color="#990000">()&gt;(</font>b<font color="#990000">);</font>
    <i><font color="#9A1900">// C#</font></i>
    <i><font color="#9A1900">// delegate void some_name();</font></i>
    <i><font color="#9A1900">// some_name fr = foo;</font></i>
    <i><font color="#9A1900">// some_name fr = b.baz;</font></i>
    <i><font color="#9A1900">///////////////////////////////</font></i>
    <i><font color="#9A1900">// Borland C++, embarcadero __closure</font></i>
    <i><font color="#9A1900">// void(__closure * fr)();</font></i>
    <i><font color="#9A1900">// fr = foo</font></i>
    <i><font color="#9A1900">// fr = b.baz</font></i>

    <b><font color="#000000">fr1</font></b><font color="#990000">();</font>
    <b><font color="#000000">fr2</font></b><font color="#990000">();</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">();</font>
    <b><font color="#000000">fr4</font></b><font color="#990000">();</font>
    <b><font color="#000000">fr5</font></b><font color="#990000">();</font>
    <b><font color="#000000">fr6</font></b><font color="#990000">();</font>
    <b><font color="#000000">fr7</font></b><font color="#990000">();</font>
    <b><font color="#000000">fr8</font></b><font color="#990000">();</font>
<font color="#FF0000">}</font>

<font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    <b><font color="#0000FF">return</font></b> <font color="#993399">42</font><font color="#990000">;</font>
<font color="#FF0000">}</font></tt></pre>

</div>
<p>Here, the type erased free and member function use cases are consistent with the free and member use cases that do not have type erasure. It is concise. Conveys the intent of the user and provides a feature found in other proramming languages that C++ users have been clamoring for well over a decade. There is an additional reason that goes to ease of use. When you use a stateful lambda to needlessly tie the type erased state to a method, you are in essence creating a new anonymous type and instance which has its own lifetime that must be managed by the user. Superflous code is being added which the optimizer has to remove. Usage of function_ref becomes harder to reason about. You in essense have a function_ref which is a reference, refering to a lambda which is a reference that references the actual object in question. This makes it harder to reason about any remaining dangling. A reference to a reference is not a reference. It is rather a pointer which has multiple levels of indirection. A reference was always a collapsable single level of indirection.</p>
<h2 id="solution">Solution</h2>
<p>This version of make_function_ref proposal speaks more to the deficiencies of the original function_ref proposal. This has not been done to provide ammunition for delaying function_ref further. Rather function_ref is API/module boundary fundamental data type which is long over do. If for any tragic reason the standardization process decides function_ref should not go forward, I beg that to whom it may concern reconsider. The problematic current constructor could be stripped out and only the internal 2 pointer constructor be provided. Even a trivial implementation where construction is left to the end user is still of abundant value. However, what is hoped that some version of the current function_ref constructor is retained and better specified. The implementation is locked to the two pointer solution and the two pointer constructor is changed to a static factory function perhaps called "construct_from_type_erased" to discourage its use but for it to be used by future or user defined construction methods such as make_function_ref.</p>
<p>The following are the minimal changes needed to support make_function_ref and other author's proposals in the future.</p>
<!-- make_function_ref-spec-min.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">F</font><font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">;</font>

<i><font color="#9A1900">/// Specializations for function types.</font></i>
<b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">R</font><font color="#990000">,</font> <b><font color="#0000FF">class</font></b><font color="#990000">...</font> Args<font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">&lt;</font><b><font color="#000000">R</font></b><font color="#990000">(</font>Args<font color="#990000">...)&gt;</font> <font color="#FF0000">{</font>
<b><font color="#0000FF">public</font></b><font color="#990000">:</font>
  <i><font color="#9A1900">// factory function to be used by make_function_ref and other user defined construction methods</font></i>
  <b><font color="#0000FF">static</font></b> <font color="#008080">function_ref&lt;R(Args...)&gt;</font> <b><font color="#000000">construct_from_type_erased</font></b><font color="#990000">(</font><font color="#009900">void</font><font color="#990000">*</font> obj_<font color="#990000">,</font> <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font>Args<font color="#990000">...))</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">;</font>
<b><font color="#0000FF">private</font></b><font color="#990000">:</font>
  <font color="#009900">void</font> <font color="#990000">*</font>obj_ <font color="#990000">=</font> nullptr<font color="#990000">;</font><i><font color="#9A1900">// NOT exposition only</font></i>
  <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font> <font color="#990000">*,</font> Args<font color="#990000">...)</font> <font color="#990000">=</font> nullptr<font color="#990000">;</font><i><font color="#9A1900">// NOT exposition only</font></i>
<font color="#FF0000">}</font><font color="#990000">;</font>

<b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">R</font><font color="#990000">,</font> <b><font color="#0000FF">class</font></b><font color="#990000">...</font> Args<font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">&lt;</font><b><font color="#000000">R</font></b><font color="#990000">(</font>Args<font color="#990000">...)</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">&gt;</font> <font color="#FF0000">{</font>
<b><font color="#0000FF">public</font></b><font color="#990000">:</font>
  <i><font color="#9A1900">// factory function to be used by make_function_ref and other user defined construction methods</font></i>
  <b><font color="#0000FF">static</font></b> <font color="#008080">function_ref&lt;R(Args...)&gt;</font> <b><font color="#000000">construct_from_type_erased</font></b><font color="#990000">(</font><font color="#009900">void</font><font color="#990000">*</font> obj_<font color="#990000">,</font> <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font>Args<font color="#990000">...))</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">;</font>
<b><font color="#0000FF">private</font></b><font color="#990000">:</font>
  <font color="#009900">void</font> <font color="#990000">*</font>obj_ <font color="#990000">=</font> nullptr<font color="#990000">;</font><i><font color="#9A1900">// NOT exposition only</font></i>
  <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font> <font color="#990000">*,</font> Args<font color="#990000">...)</font> <b><font color="#0000FF">noexcept</font></b> <font color="#990000">=</font> nullptr<font color="#990000">;</font><i><font color="#9A1900">// NOT exposition only</font></i>
<font color="#FF0000">}</font><font color="#990000">;</font></tt></pre>

</div>
<p>The following are all the changes needed to adopt make_function_ref into the current function_ref proposal.</p>
<!-- make_function_ref-spec-max.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">F</font><font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">;</font>

<i><font color="#9A1900">/// Specializations for function types.</font></i>
<b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">R</font><font color="#990000">,</font> <b><font color="#0000FF">class</font></b><font color="#990000">...</font> Args<font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">&lt;</font><b><font color="#000000">R</font></b><font color="#990000">(</font>Args<font color="#990000">...)&gt;</font> <font color="#FF0000">{</font>
<b><font color="#0000FF">public</font></b><font color="#990000">:</font>
  <i><font color="#9A1900">// factory function to be used by make_function_ref and other user defined construction methods</font></i>
  <b><font color="#0000FF">static</font></b> <font color="#008080">function_ref&lt;R(Args...)&gt;</font> <b><font color="#000000">construct_from_type_erased</font></b><font color="#990000">(</font><font color="#009900">void</font><font color="#990000">*</font> obj_<font color="#990000">,</font> <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font>Args<font color="#990000">...))</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">;</font>
<b><font color="#0000FF">private</font></b><font color="#990000">:</font>
  <font color="#009900">void</font> <font color="#990000">*</font>obj_ <font color="#990000">=</font> nullptr<font color="#990000">;</font><i><font color="#9A1900">// NOT exposition only</font></i>
  <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font> <font color="#990000">*,</font> Args<font color="#990000">...)</font> <font color="#990000">=</font> nullptr<font color="#990000">;</font><i><font color="#9A1900">// NOT exposition only</font></i>
<font color="#FF0000">}</font><font color="#990000">;</font>

<b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">R</font><font color="#990000">,</font> <b><font color="#0000FF">class</font></b><font color="#990000">...</font> Args<font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">&lt;</font><b><font color="#000000">R</font></b><font color="#990000">(</font>Args<font color="#990000">...)</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">&gt;</font> <font color="#FF0000">{</font>
<b><font color="#0000FF">public</font></b><font color="#990000">:</font>
  <i><font color="#9A1900">// factory function to be used by make_function_ref and other user defined construction methods</font></i>
  <b><font color="#0000FF">static</font></b> <font color="#008080">function_ref&lt;R(Args...)&gt;</font> <b><font color="#000000">construct_from_type_erased</font></b><font color="#990000">(</font><font color="#009900">void</font><font color="#990000">*</font> obj_<font color="#990000">,</font> <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font>Args<font color="#990000">...))</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">;</font>
<b><font color="#0000FF">private</font></b><font color="#990000">:</font>
  <font color="#009900">void</font> <font color="#990000">*</font>obj_ <font color="#990000">=</font> nullptr<font color="#990000">;</font><i><font color="#9A1900">// NOT exposition only</font></i>
  <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font> <font color="#990000">*,</font> Args<font color="#990000">...)</font> <b><font color="#0000FF">noexcept</font></b> <font color="#990000">=</font> nullptr<font color="#990000">;</font><i><font color="#9A1900">// NOT exposition only</font></i>
<font color="#FF0000">}</font><font color="#990000">;</font>

<b><font color="#0000FF">template</font></b><font color="#990000">&lt;</font><b><font color="#0000FF">auto</font></b> mf<font color="#990000">,</font> <b><font color="#0000FF">typename</font></b> <font color="#008080">T</font><font color="#990000">&gt;</font> <font color="#008080">requires</font> std<font color="#990000">::</font>is_member_function_pointer<font color="#990000">&lt;</font><b><font color="#0000FF">decltype</font></b><font color="#990000">(</font>mf<font color="#990000">)&gt;::</font>value
<b><font color="#0000FF">auto</font></b> <b><font color="#000000">make_function_ref</font></b><font color="#990000">(</font>T<font color="#990000">&amp;</font> obj<font color="#990000">);</font>

<b><font color="#0000FF">template</font></b><font color="#990000">&lt;</font><b><font color="#0000FF">auto</font></b> mf<font color="#990000">,</font> <b><font color="#0000FF">typename</font></b> <font color="#008080">T</font><font color="#990000">&gt;</font> <font color="#008080">requires</font> std<font color="#990000">::</font>is_member_function_pointer<font color="#990000">&lt;</font><b><font color="#0000FF">decltype</font></b><font color="#990000">(</font>mf<font color="#990000">)&gt;::</font>value
<b><font color="#0000FF">auto</font></b> <b><font color="#000000">make_function_ref</font></b><font color="#990000">(</font><b><font color="#0000FF">const</font></b> T<font color="#990000">&amp;</font> obj<font color="#990000">);</font>

<b><font color="#0000FF">template</font></b><font color="#990000">&lt;</font><b><font color="#0000FF">typename</font></b> <font color="#008080">testType</font><font color="#990000">&gt;</font>
<b><font color="#0000FF">struct</font></b> <font color="#008080">is_function_pointer</font>
<font color="#FF0000">{</font>
    <b><font color="#0000FF">static</font></b> <b><font color="#0000FF">const</font></b> <font color="#009900">bool</font> value <font color="#990000">=</font>
        std<font color="#990000">::</font>is_pointer<font color="#990000">&lt;</font>testType<font color="#990000">&gt;::</font>value <font color="#990000">?</font>
        std<font color="#990000">::</font>is_function<font color="#990000">&lt;</font><b><font color="#0000FF">typename</font></b> <font color="#008080">std</font><font color="#990000">::</font>remove_pointer<font color="#990000">&lt;</font>testType<font color="#990000">&gt;::</font>type<font color="#990000">&gt;::</font>value <font color="#990000">:</font>
        <b><font color="#0000FF">false</font></b><font color="#990000">;</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<b><font color="#0000FF">template</font></b><font color="#990000">&lt;</font><b><font color="#0000FF">auto</font></b> f<font color="#990000">,</font> <b><font color="#0000FF">typename</font></b> <font color="#008080">T</font><font color="#990000">&gt;</font> <font color="#008080">requires</font> is_function_pointer<font color="#990000">&lt;</font><b><font color="#0000FF">decltype</font></b><font color="#990000">(</font>f<font color="#990000">)&gt;::</font>value
<b><font color="#0000FF">auto</font></b> <b><font color="#000000">make_function_ref</font></b><font color="#990000">(</font>T<font color="#990000">&amp;</font> obj<font color="#990000">);</font>

<b><font color="#0000FF">template</font></b><font color="#990000">&lt;</font><b><font color="#0000FF">auto</font></b> f<font color="#990000">,</font> <b><font color="#0000FF">typename</font></b> <font color="#008080">T</font><font color="#990000">&gt;</font> <font color="#008080">requires</font> is_function_pointer<font color="#990000">&lt;</font><b><font color="#0000FF">decltype</font></b><font color="#990000">(</font>f<font color="#990000">)&gt;::</font>value
<b><font color="#0000FF">auto</font></b> <b><font color="#000000">make_function_ref</font></b><font color="#990000">(</font><b><font color="#0000FF">const</font></b> T<font color="#990000">&amp;</font> obj<font color="#990000">);</font></tt></pre>

</div>
<h2 id="ftm">Feature test macro</h2>
<p>We do not need a feature macro, because we intend for this paper to modify std::function_ref before it ships.</p>
<h2 id="implementation">Example implementation</h2>
<p>The most up-to-date implementation, created by Jarrad Waterloo, is available on <a href="#make_function_ref-implementation">Github</a></p>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>Thanks to Arthur O'Dwyer and Tomasz Kamiński for providing very valuable feedback on earlier drafts of this proposal.</p>
<h2 id="alternative">Annex: alternative design decisions</h2>
<h3 id="auto">Why not just use [&b](auto... args){b.baz(args...);}?</h3>
<p>While succinct, this does have some undesirable consequences.</p>
<ul>
<li>It is more complex; at least cognitively speaking. The only pieces the end user really cares about is either "=baz" or "=b.baz". The capture, the parameter propagation even with auto and the occassional return are all superfluous.</li>
<li>If this was a C function pointer would the end user be happy with that versus just assigning with "= some_function". In this case the public wrapper interface is more complicated than the internals. Shouldn't that be reversed i.e. abstraction.</li>
<li>Using a functor or stateful lambda does require creating a object and type even if anonymous that has a lifetime that must be managed making things more complicated.</li>
<li>Construction which should be one step has now been broken into two which is more cumbersome; see the next decision.</li>
</ul>
<h3 id="general-purpose-callable-library">Why not just use bind_front and turn the remaining make_function_ref implementations into a general purpose functors library?</h3>
<p>I actually agree that C++ could use a separate function transformation library for the general cases but I don't think that should negate function_ref supporting compatible signatures; i.e. first class support. Such a general purpose library would turn what should be a one step construction process into a two step process; first create a functor and then assign it to the function_ref. Personally I prefer one step and here is why. function_ref is to function pointer, in C, as std::array is to C/C++ array. It is more intuitive/familiar to the end user. a function pointer is simply assigned for compatible/comparable signatures and the end user must create a new function for incompatible signatures in order to do conversions or reordering of parameters and in the case of functors, adding more parameters. This two phase construction is more verbose. make_function_ref is less so and the same name regardless of what is being assigned. It is also similar to make_pair, make_shared_ptr and the other single step make functions; again familiar. I would hesitate to say that end users expect a simple construction methodology based on the prevalence of simpler solutions in other languages and there is no good reason why we should make things deliberately harder especially for common cases when it is not needed to be so.</p>
<p>It should also be noted that their are current C++ limitations that restrict our implementation choices.</p>
<ul>
<li>C++ template constructors do not support explicit template parameters meaning having to resort to tag classes which make things more verbose.</li>
<li>Template functions do not support partial specialization meaning such things that should simply be performed by functions has to be performed by whole partially specialized classes making things more verbose.</li>
<li>Making heavily templatized make_function_ref functions into FRIEND functions of function_ref is borderline impossible, if not so. This is why I still need my public double pointer constructor. I am still for having this constructor anyway for advance end users to prototype other compatible signatures for operators and other function like constructs in C++ that currently don't have a natural binding.</li>
</ul>
<p>At present, my current make_function_ref solution seems to provide a very concise single step construction that enhances function_ref to support better the 4 use cases: [non] type erased [member/free] functions.</p>
<h2 id="references">References</h2>
<span id="reference-p0792r5">[P0792R5] function_ref: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r5.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r5.html</a><br/>
<br/>
<span id="reference-github">function_ref</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://github.com/TartanLlama/function_ref" target="__blank">https://github.com/TartanLlama/function_ref</a><br/>
<br/>
<span id="make_function_ref-implementation">make_function_ref implementation</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://raw.githubusercontent.com/descender76/cpp_proposals/main/function_ref/function_ref_prime.hpp" target="__blank">https://raw.githubusercontent.com/descender76/cpp_proposals/main/function_ref/function_ref_prime.hpp</a><br/>
<br/>
<span id="reference-delegate">Using Delegates (C# Programming Guide)</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/using-delegates" target="__blank">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/using-delegates</a><br/>
<br/>
<span id="reference-closure">__closure</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://docwiki.embarcadero.com/RADStudio/Sydney/en/Closure" target="__blank">http://docwiki.embarcadero.com/RADStudio/Sydney/en/Closure</a><br/>
<br/>
<span id="reference-fastest">Member Function Pointers and the Fastest Possible C++ Delegates</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible" target="__blank">https://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible</a><br/>
<br/>
<span id="reference-fast">The Impossibly Fast C++ Delegates</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates" target="__blank">https://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates</a><br/>
<br/>
<span id="reference-impossibly">Impossibly fast delegate in C++11</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://codereview.stackexchange.com/questions/14730/impossibly-fast-delegate-in-c11" target="__blank">https://codereview.stackexchange.com/questions/14730/impossibly-fast-delegate-in-c11</a><br/>
<br/>
<span id="reference-dyno">Dyno: Runtime polymorphism done right</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://github.com/ldionne/dyno" target="__blank">https://github.com/ldionne/dyno</a><br/>
<br/>
<span id="reference-te">[Boost::ext].TE</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://github.com/boost-ext/te" target="__blank">https://github.com/boost-ext/te</a><br/>
<br/>
</body>
</html>
