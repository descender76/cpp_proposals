<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>make_function_ref: A More Functional function_ref</title>
  <meta name="description" content="make_function_ref: A More Functional function_ref">
  <meta name="author" content="Jarrad Waterloo">
  <style>
    h1
	{
	  text-align : center;
	}
	.code
	{
	  background-color: AliceBlue;
	}
	table.simple
	{
		border: 1px solid black;
		border-collapse: collapse;
	}
	table.simple > thead > tr > th
	{
		border: 1px solid black;
	}
	table.simple > tbody > tr > td
	{
		border: 1px solid black;
	}
	.problem
	{
		font-weight : bold;
		color : red;
	}
  </style>
</head>
<body>
<h1>make_function_ref: A More Functional function_ref</h1>
<table style="width:100%">
<tr>
<td>&nbsp;</td>
<td style="width:60ex">
  <table>
  <tr>
  <td><b>Document #:</b></td><td>P2472R1</td>
  </tr>
  <tr>
  <td><b>Date:</b></td><td>2021-12-06</td>
  </tr>
  <tr>
  <td><b>Project:</b></td><td>Programming Language C++</td>
  </tr>
  <tr>
  <td><b>Audience:</b></td><td>Library Evolution Working Group (LEWG)</td>
  </tr>
  <tr>
  <td><b>Reply-to:</b></td><td>Jarrad J. Waterloo<br/>&lt;<a href="mailto:descender76@gmail.com">descender76@gmail.com</a>&gt;</td>
  </tr>
  </table>
</td>
</tr>
</table>
<h2>Contents</h2>
<h3><a href="#abstract">1&nbsp;&nbsp;Abstract</a></h3>
<h3><a href="#motivating-overview">2&nbsp;&nbsp;Motivating overview</a></h3>
<h3><a href="#solution">3&nbsp;&nbsp;Solution</a></h3>
<!--<h3><a href="#overview">4&nbsp;&nbsp;Overview</a></h3>-->
<h3><a href="#motivating-examples">4&nbsp;&nbsp;Motivating examples</a></h3>
<h3><a href="#ftm">5&nbsp;&nbsp;Feature test macro</a></h3>
<h3><a href="#other-languages">6&nbsp;&nbsp;Other Languages</a></h3>
<h3><a href="#implementation">7&nbsp;&nbsp;Example implementation</a></h3>
<h3><a href="#acknowledgments">8&nbsp;&nbsp;Acknowledgments</a></h3>
<h3><a href="#alternative">9&nbsp;&nbsp;Annex: alternative design decisions</a></h3>
<h4><a href="#auto">9.1&nbsp;&nbsp;&nbsp;auto</a></h4>
<h4><a href="#general-purpose-callable-library">9.2&nbsp;&nbsp;&nbsp;General Purpose Callable Library</a></h4>
<h3><a href="#references">10&nbsp;&nbsp;References</a></h3>
<h2 id="abstract">Abstract</h2>
<!--
<p>This paper proposes the addition of two make_function_ref functions to the current <a href="#reference-p0792r5">function_ref</a> proposal to better handle "member function with type erasure" and "free function with type erasure" usecases.</p>
<p>The current <a href="#reference-p0792r5">function_ref</a> proposal is closely modeled as a drop in replacement for std::function. It is assumed that it works the same but is referenced based instead of copy based. As such the current proposal provides little direction as to how it may be constructed and used safely. While std::function is more intuitive, function_ref is less so. Further with the change to reference based, function_ref is capable of so much more than what is provided, since it being modeled after std::function which was designed with copying in mind.</p>
-->
<p>I propose to make <a href="#reference-p0792r5">function_ref</a> easier and safer to use with pointer-to-member-functions by adding a std::make_function_ref factory function. Also the pointer-to-free-function and pointer-to-member-function cases should be expanded to easily and safely include type erased state just like functors and capturing lambdas has.</p>
<h2 id="motivating-overview">Motivating overview</h2>
<p>
<ul>
<li>std::function_ref has an api similar to that of std::function. However, its constructors are hard to use correctly with pointer-to-member-function and other common use cases.</li>
<li>std::function_ref currently has no interface to allow it to store the this pointer. This is an intentional design choice of P0792 (which tries to be consistent with the language-syntax of pointer-to-member-function). However I found that interface to be surprising, and often leading to access to dangling objects.</li>
<li>Because function_ref is expected to be a reference to a callable, we can support proper pointer-to-member-function usage without increasing the size of the std::function_ref (no copy needs to be made).</li>
</ul>
</p>
<h2 id="solution">Solution</h2>
<!--
<p>This version of make_function_ref proposal speaks more to the deficiencies of the original function_ref proposal. This has not been done to provide ammunition for delaying function_ref further. Rather function_ref is API/module boundary fundamental data type which is long over do. If for any tragic reason the standardization process decides function_ref should not go forward, I beg that to whom it may concern reconsider. The problematic current constructor could be stripped out and only the internal 2 pointer constructor be provided. Even a trivial implementation where construction is left to the end user is still of abundant value. However, what is hoped that some version of the current function_ref constructor is retained and better specified. The implementation is locked to the two pointer solution and the two pointer constructor is changed to a static factory function perhaps called "construct_from_type_erased" to discourage its use but for it to be used by future or user defined construction methods such as make_function_ref.</p>
-->
<h3 id="solution">Proposal #1 - The minimal proposal</h3>
<p>The following are the minimal changes needed to support make_function_ref and other author's proposals in the future. It consists of 2 changes to the current function_ref proposal.</p>
<p>
<ol>
<li>Tie down the specification to a double pointer implementation; a void* of state and a free function pointer that takes that state as its first perameter. In short, remove the exposition only from the class definition in the current function_ref proposal.</li>
<li>Add a static factory function, named "construct_from_type_erased", that trivially initialize the two aforementioned pointers.</li>
</ol>
</p>
<p>Not making this change in C++23 would constitute a breaking change because it would require implementations that did not use the two pointer solution to have to change.</p>
<!-- make_function_ref-spec-min.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">F</font><font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">;</font>

<i><font color="#9A1900">/// Specializations for function types.</font></i>
<b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">R</font><font color="#990000">,</font> <b><font color="#0000FF">class</font></b><font color="#990000">...</font> Args<font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">&lt;</font><b><font color="#000000">R</font></b><font color="#990000">(</font>Args<font color="#990000">...)&gt;</font> <font color="#FF0000">{</font>
<b><font color="#0000FF">public</font></b><font color="#990000">:</font>
  <i><font color="#9A1900">// factory function to be used by make_function_ref and other user defined construction methods</font></i>
  <b><font color="#0000FF">static</font></b> <font color="#008080">function_ref&lt;R(Args...)&gt;</font> <b><font color="#000000">construct_from_type_erased</font></b><font color="#990000">(</font><font color="#009900">void</font><font color="#990000">*</font> obj_<font color="#990000">,</font> <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font>Args<font color="#990000">...))</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">;</font>
<b><font color="#0000FF">private</font></b><font color="#990000">:</font>
  <font color="#009900">void</font><font color="#990000">*</font> erased_object<font color="#990000">;</font>
  <b><font color="#000000">R</font></b><font color="#990000">(*</font>erased_function<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font> Args<font color="#990000">...);</font>
  <i><font color="#9A1900">// NOTE:</font></i>
  <i><font color="#9A1900">// 1) The following has been removed: // exposition only</font></i>
  <i><font color="#9A1900">// 2) "void*, " was added to erased_function</font></i>
<font color="#FF0000">}</font><font color="#990000">;</font>

<i><font color="#9A1900">// NOTE: noexcept version was added</font></i>
<b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">R</font><font color="#990000">,</font> <b><font color="#0000FF">class</font></b><font color="#990000">...</font> Args<font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">&lt;</font><b><font color="#000000">R</font></b><font color="#990000">(</font>Args<font color="#990000">...)</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">&gt;</font> <font color="#FF0000">{</font>
<b><font color="#0000FF">public</font></b><font color="#990000">:</font>
  <i><font color="#9A1900">// factory function to be used by make_function_ref and other user defined construction methods</font></i>
  <b><font color="#0000FF">static</font></b> <font color="#008080">function_ref&lt;R(Args...)&gt;</font> <b><font color="#000000">construct_from_type_erased</font></b><font color="#990000">(</font><font color="#009900">void</font><font color="#990000">*</font> obj_<font color="#990000">,</font> <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font>Args<font color="#990000">...))</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">;</font>
<b><font color="#0000FF">private</font></b><font color="#990000">:</font>
  <font color="#009900">void</font><font color="#990000">*</font> erased_object<font color="#990000">;</font>
  <b><font color="#000000">R</font></b><font color="#990000">(*</font>erased_function<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font> Args<font color="#990000">...);</font>
<font color="#FF0000">}</font><font color="#990000">;</font></tt></pre>

</div>
<h3 id="solution">Proposal #2 - The make_function_ref proposal</h3>
<!--<p>The following are all the changes needed to adopt make_function_ref into the current function_ref proposal.</p>-->
<p>The make_function_ref proposal is a superset of the minimal proposal. It utilizes the "construct_from_type_erased" plumbing function to create the type safe "make_function_ref" factory functions. These functions DO NOT replace the current constructor. While, the current function_ref proposal is focused on callables, callable objects, such as functors and lambda functions, make_function_ref is focused on functions in general. While the current function_ref constructor handles implicit conversion of parameters, make_function_ref handles explicit simple assignment of ~exact signatures. This focus of make_function_ref makes it easier in general and safer when it comes to dangling. Other than when these two construction methodologies overlap with the stateless free and member function pointers, they are largely complimentary.</p>
<!-- make_function_ref-spec-max.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">F</font><font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">;</font>

<i><font color="#9A1900">/// Specializations for function types.</font></i>
<b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">R</font><font color="#990000">,</font> <b><font color="#0000FF">class</font></b><font color="#990000">...</font> Args<font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">&lt;</font><b><font color="#000000">R</font></b><font color="#990000">(</font>Args<font color="#990000">...)&gt;</font> <font color="#FF0000">{</font>
<b><font color="#0000FF">public</font></b><font color="#990000">:</font>
  <i><font color="#9A1900">// factory function to be used by make_function_ref and other user defined construction methods</font></i>
  <b><font color="#0000FF">static</font></b> <font color="#008080">function_ref&lt;R(Args...)&gt;</font> <b><font color="#000000">construct_from_type_erased</font></b><font color="#990000">(</font><font color="#009900">void</font><font color="#990000">*</font> obj_<font color="#990000">,</font> <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font>Args<font color="#990000">...))</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">;</font>
<b><font color="#0000FF">private</font></b><font color="#990000">:</font>
  <font color="#009900">void</font><font color="#990000">*</font> erased_object<font color="#990000">;</font>
  <b><font color="#000000">R</font></b><font color="#990000">(*</font>erased_function<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font> Args<font color="#990000">...);</font>
  <i><font color="#9A1900">// NOTE:</font></i>
  <i><font color="#9A1900">// 1) The following has been removed: // exposition only</font></i>
  <i><font color="#9A1900">// 2) "void*, " was added to erased_function</font></i>
<font color="#FF0000">}</font><font color="#990000">;</font>

<i><font color="#9A1900">// NOTE: noexcept version was added</font></i>
<b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">R</font><font color="#990000">,</font> <b><font color="#0000FF">class</font></b><font color="#990000">...</font> Args<font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">&lt;</font><b><font color="#000000">R</font></b><font color="#990000">(</font>Args<font color="#990000">...)</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">&gt;</font> <font color="#FF0000">{</font>
<b><font color="#0000FF">public</font></b><font color="#990000">:</font>
  <i><font color="#9A1900">// factory function to be used by make_function_ref and other user defined construction methods</font></i>
  <b><font color="#0000FF">static</font></b> <font color="#008080">function_ref&lt;R(Args...)&gt;</font> <b><font color="#000000">construct_from_type_erased</font></b><font color="#990000">(</font><font color="#009900">void</font><font color="#990000">*</font> obj_<font color="#990000">,</font> <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font>Args<font color="#990000">...))</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">;</font>
<b><font color="#0000FF">private</font></b><font color="#990000">:</font>
  <font color="#009900">void</font><font color="#990000">*</font> erased_object<font color="#990000">;</font>
  <b><font color="#000000">R</font></b><font color="#990000">(*</font>erased_function<font color="#990000">)(</font>Args<font color="#990000">...);</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<b><font color="#0000FF">template</font></b><font color="#990000">&lt;</font><b><font color="#0000FF">auto</font></b> mf<font color="#990000">,</font> <b><font color="#0000FF">typename</font></b> <font color="#008080">T</font><font color="#990000">&gt;</font> <font color="#008080">requires</font> std<font color="#990000">::</font>is_member_function_pointer<font color="#990000">&lt;</font><b><font color="#0000FF">decltype</font></b><font color="#990000">(</font>mf<font color="#990000">)&gt;::</font>value
<b><font color="#0000FF">auto</font></b> <b><font color="#000000">make_function_ref</font></b><font color="#990000">(</font>T<font color="#990000">&amp;</font> obj<font color="#990000">);</font>

<b><font color="#0000FF">template</font></b><font color="#990000">&lt;</font><b><font color="#0000FF">auto</font></b> mf<font color="#990000">,</font> <b><font color="#0000FF">typename</font></b> <font color="#008080">T</font><font color="#990000">&gt;</font> <font color="#008080">requires</font> std<font color="#990000">::</font>is_member_function_pointer<font color="#990000">&lt;</font><b><font color="#0000FF">decltype</font></b><font color="#990000">(</font>mf<font color="#990000">)&gt;::</font>value
<b><font color="#0000FF">auto</font></b> <b><font color="#000000">make_function_ref</font></b><font color="#990000">(</font><b><font color="#0000FF">const</font></b> T<font color="#990000">&amp;</font> obj<font color="#990000">);</font>

<b><font color="#0000FF">template</font></b><font color="#990000">&lt;</font><b><font color="#0000FF">auto</font></b> mf<font color="#990000">&gt;</font> <font color="#008080">requires</font> std<font color="#990000">::</font>is_member_function_pointer<font color="#990000">&lt;</font><b><font color="#0000FF">decltype</font></b><font color="#990000">(</font>mf<font color="#990000">)&gt;::</font>value
<b><font color="#0000FF">auto</font></b> <b><font color="#000000">make_function_ref</font></b><font color="#990000">();</font>

<b><font color="#0000FF">template</font></b><font color="#990000">&lt;</font><b><font color="#0000FF">typename</font></b> <font color="#008080">testType</font><font color="#990000">&gt;</font>
<b><font color="#0000FF">struct</font></b> <font color="#008080">is_function_pointer</font>
<font color="#FF0000">{</font>
    <b><font color="#0000FF">static</font></b> <b><font color="#0000FF">const</font></b> <font color="#009900">bool</font> value <font color="#990000">=</font> std<font color="#990000">::</font>is_function_v<font color="#990000">&lt;</font>std<font color="#990000">::</font>remove_pointer_t<font color="#990000">&lt;</font>testType<font color="#990000">&gt;&gt;;</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<b><font color="#0000FF">template</font></b><font color="#990000">&lt;</font><b><font color="#0000FF">auto</font></b> f<font color="#990000">,</font> <b><font color="#0000FF">typename</font></b> <font color="#008080">T</font><font color="#990000">&gt;</font> <font color="#008080">requires</font> is_function_pointer<font color="#990000">&lt;</font><b><font color="#0000FF">decltype</font></b><font color="#990000">(</font>f<font color="#990000">)&gt;::</font>value
<b><font color="#0000FF">auto</font></b> <b><font color="#000000">make_function_ref</font></b><font color="#990000">(</font>T<font color="#990000">&amp;</font> obj<font color="#990000">);</font>

<b><font color="#0000FF">template</font></b><font color="#990000">&lt;</font><b><font color="#0000FF">auto</font></b> f<font color="#990000">,</font> <b><font color="#0000FF">typename</font></b> <font color="#008080">T</font><font color="#990000">&gt;</font> <font color="#008080">requires</font> is_function_pointer<font color="#990000">&lt;</font><b><font color="#0000FF">decltype</font></b><font color="#990000">(</font>f<font color="#990000">)&gt;::</font>value
<b><font color="#0000FF">auto</font></b> <b><font color="#000000">make_function_ref</font></b><font color="#990000">(</font><b><font color="#0000FF">const</font></b> T<font color="#990000">&amp;</font> obj<font color="#990000">);</font>

<b><font color="#0000FF">template</font></b><font color="#990000">&lt;</font><b><font color="#0000FF">auto</font></b> f<font color="#990000">&gt;</font> <font color="#008080">requires</font> is_function_pointer<font color="#990000">&lt;</font><b><font color="#0000FF">decltype</font></b><font color="#990000">(</font>f<font color="#990000">)&gt;::</font>value
<b><font color="#0000FF">auto</font></b> <b><font color="#000000">make_function_ref</font></b><font color="#990000">();</font></tt></pre>

</div>
<h3 id="solution">Proposal #2++ - The make_function_ref++ proposal</h3>
<p>"function_ref" and "make_function_ref" overlap when it comes to [stateless] assigning of a free or member function.</p>
<p>
<table class="simple">
<tr>
<td colspan="3" style="text-align:center">make_function_ref</td>
<td style="text-align:center">vs</td>
<td colspan="3" style="text-align:center">function_ref</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>Stateless</td>
<td>Stateful</td>
<td>&nbsp;</td>
<td>Stateless</td>
<td>Stateful</td>
</tr>
<tr>
<td>Free Function</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&nbsp;</td>
<td>&#x2713; different</td>
<td>&#x2717; use capturing lambda</td>
</tr>
<tr>
<td>Member Function</td>
<td>&#x2713;</td>
<td>&#x2713;</td>
<td>&nbsp;</td>
<td>&#x2717; dangle</td>
<td>&#x2717; use capturing lambda</td>
</tr>
</table>
</p>
<p>The questions are should either free or member function assignment be removed from function_ref or make_function_ref!</p>
<h4>Should the make_function_ref proposal or the function_ref proposal drop initialization from a free function?</h4>
<p>The make_function_ref implementation is not the same as the function_ref implementation. In make_function_ref, a free function is passed as a template parameter making it more compile time. The internal state pointer goes unused and likely initialized to nullptr. The function_ref implementation is more runtime by storing the function pointer in the internal state pointer member of function_ref. In this case, the function_ref proposal is easier in the sense of a constructor over a factory function. It is also more flexible in the sense a user can wait latter in their code to bind the function pointer to the function_ref. make_function_ref is more consistent with the other three use case where it is clearly better. Also just like strongly typed primitive types such as email alias type vs the string it is based upon, code quality improves by using function_ref sooner rather than latter. Despite these differences, the gains of having both out weigh the small overlap in functionality.</p>
<h4>Should the make_function_ref proposal drop initialization from a member function?</h4>
<p>Perish the thought. "make_function_ref" does not dangle, the current function_ref proposal can. "make_function_ref" is consistent with its other three use cases.</p>
<h4>Should the function_ref proposal drop initialization from a member function?</h4>
<p>That depends. Should the standardization process go with just the minimal interface i.e. without make_function_ref, than it should remain. Having it is just clunky and users can just learn the multiple right ways of doing things and be on guard against the easy wrong way of doing things that lead to dangling. However, if the standardization does go with the make_function_ref factory functions then MAYBE. Removing it would just be a matter of adding something like " requires !std::is_member_function_pointer<decltype(mf)>::value" to the constructor in the current function_ref proposal. However, for consistency sake, since function_ref can take a free function pointer it could be argued to keep it in. In either case, it doesn't negate the need of the make_function_ref factory functions to address the four free and member, stateless and stateful function pointer use cases.</p>
<h3 id="solution">Proposal #3 - The scorched Earth/nuclear option</h3>
<p>For all the advantages mentioned in the current function_ref proposal, function_ref is an important vocabulary type that like v-table interfaces or traits live and breath on the API/module boundary. If there is any hint of function_ref, with or without make_function_ref, NOT being stanardized in C++23 than I would hope the following is considered instead. Don't have the make_function_ref factory functions. Don't have the current constructor in the current function_ref proposal. Rather, just have the explicit double pointer implementation and the construct_from_type_erased factory function. There is still value in a trivial function_ref even while its construction methodologies gets straightened out in C++26.</p>
<!-- function_ref-trivial.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><b><font color="#0000FF">namespace</font></b> std
<font color="#FF0000">{</font>
    <b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">typename</font></b> <font color="#008080">Signature</font><font color="#990000">&gt;</font>
    <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font>
    <font color="#FF0000">{</font>
        <font color="#009900">void</font><font color="#990000">*</font> erased_object<font color="#990000">;</font>

        <b><font color="#000000">R</font></b><font color="#990000">(*</font>erased_function<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font> Args<font color="#990000">...);</font>
        <i><font color="#9A1900">// `R`, and `Args...` are the return type, and the parameter-type-list,</font></i>
        <i><font color="#9A1900">// of the function type `Signature`, respectively.</font></i>

    <b><font color="#0000FF">public</font></b><font color="#990000">:</font>
        <i><font color="#9A1900">// factory function to be used by make_function_ref and other user defined construction methods</font></i>
        <b><font color="#0000FF">static</font></b> <font color="#008080">function_ref&lt;R(Args...)&gt;</font> <b><font color="#000000">construct_from_type_erased</font></b><font color="#990000">(</font><font color="#009900">void</font><font color="#990000">*</font> obj_<font color="#990000">,</font> <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font>Args<font color="#990000">...))</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">;</font>

        <b><font color="#000000">function_ref</font></b><font color="#990000">(</font><b><font color="#0000FF">const</font></b> function_ref<font color="#990000">&amp;)</font> <b><font color="#0000FF">noexcept</font></b> <font color="#990000">=</font> <b><font color="#0000FF">default</font></b><font color="#990000">;</font>

        <b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">typename</font></b> <font color="#008080">F</font><font color="#990000">&gt;</font>
        <b><font color="#000000">function_ref</font></b><font color="#990000">(</font>F<font color="#990000">&amp;&amp;);</font>

        function_ref<font color="#990000">&amp;</font> <b><font color="#0000FF">operator</font></b><font color="#990000">=(</font><b><font color="#0000FF">const</font></b> function_ref<font color="#990000">&amp;)</font> <b><font color="#0000FF">noexcept</font></b> <font color="#990000">=</font> <b><font color="#0000FF">default</font></b><font color="#990000">;</font>

        <b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">typename</font></b> <font color="#008080">F</font><font color="#990000">&gt;</font>
        function_ref<font color="#990000">&amp;</font> <b><font color="#0000FF">operator</font></b><font color="#990000">=(</font>F<font color="#990000">&amp;&amp;);</font>

        <font color="#009900">void</font> <b><font color="#000000">swap</font></b><font color="#990000">(</font>function_ref<font color="#990000">&amp;)</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">;</font>

        <font color="#008080">R</font> <b><font color="#0000FF">operator</font></b><font color="#990000">()(</font>Args<font color="#990000">...)</font> <b><font color="#0000FF">const</font></b> <b><font color="#0000FF">noexcept</font></b><font color="#990000">(</font><font color="#008080">see</font> below<font color="#990000">);</font>
        <i><font color="#9A1900">// `R` and `Args...` are the return type and the parameter-type-list</font></i>
        <i><font color="#9A1900">// of the function type `Signature`, respectively.</font></i>
    <font color="#FF0000">}</font><font color="#990000">;</font>

    <b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">typename</font></b> <font color="#008080">Signature</font><font color="#990000">&gt;</font>
    <font color="#009900">void</font> <b><font color="#000000">swap</font></b><font color="#990000">(</font>function_ref<font color="#990000">&lt;</font>Signature<font color="#990000">&gt;&amp;,</font> function_ref<font color="#990000">&lt;</font>Signature<font color="#990000">&gt;&amp;)</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">;</font>
<font color="#FF0000">}</font></tt></pre>

</div>
<!--
<h2 id="overview">Overview</h2>
<p>"function_ref" <b>ONLY</b> has <b>ONE</b>, non copy, constructor which takes a const reference to a functor. The "erased_object/obj_" points to the functor and the "erased_function/callback_" points to a binding function that calls the functor's call operator receiving not only the operator parameters but also the "erased_object/obj_". "function_ref" can be created by binding a functor/stateful lambda, a C function pointer/stateless lambda and a C++ member function pointer. There are important differences between these 3 use cases. The functor/stateful lambda use case supports type erased state while the C function pointer/stateless lambda and a C++ member function pointer use cases do not. In order to type erase one parameter of a free function or the this parameter of a member function a functor/stateful lambda must be created to hold the reference to the desired state. This exposes some of the limitations of the current function_ref's proposal. "std::array" is to the C array AS function_ref is to the C function pointer. function_ref is tedious when it comes to being to assign functional things of ~exact function signature while C function pointers are not. Usage of NON typed erased [member] functions is easier to construct than using type erased [member] functions. Type erased [member] functions is generally more common and definitely more useful than their NON type erased counterparts.</p>
<p>Consider for a moment the use case of type erased member functions. This type of single function runtime polymorphism is found throughout the OOP programming world. For instance, in the .NET world, such as C#, has <a href="#reference-delegate">single and multi cast delegates</a>. Embarcadero C++'s has it via their<a href="#reference-closure">__closure</a>. This has also been peddled in the standard C++ world via articles such as <a href="#reference-fastest">Member Function Pointers and the Fastest Possible C++ Delegates</a>, <a href="#reference-fast">The Impossibly Fast C++ Delegate</a> and <a href="#reference-impossibly">Impossibly fast delegate in C++11</a>. One thing all of these implementations have in common is the ability to easily create these delegates via a constructor with two parameters; the instance to be type erased and the member function pointer.</p>
<p>Similarly too, the use case of type erased functions has been instrumental in the functional programming world for decades in C and other programming languages. The utility of simplifying the construction of these common use cases are demonstrated below.</p>
-->
<h2 id="motivating-examples">Motivating examples</h2>
<p>In order to be able to identify such areas of improvement, we need to look at the <a href="#reference-github">reference implementation</a> for function_ref. This also requires that we, momentarily, add one constructor that provides direct access to its two pointers. This constructor serves the same purpose as the proposed static factory function named "construct_from_type_erased" in the previous solution. A constructor is instead used here to reduce the additional syntax in order to ensure we are making a fair comparison between the varying construction methods.</p>
<h3 id="the-given">The given</h3>
<!-- make_function_ref-constructor-only.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">F</font><font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">;</font>

<i><font color="#9A1900">/// Specializations for function types.</font></i>
<b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">R</font><font color="#990000">,</font> <b><font color="#0000FF">class</font></b><font color="#990000">...</font> Args<font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">&lt;</font><b><font color="#000000">R</font></b><font color="#990000">(</font>Args<font color="#990000">...)&gt;</font> <font color="#FF0000">{</font>
<b><font color="#0000FF">public</font></b><font color="#990000">:</font>
  <b><font color="#000000">function_ref</font></b><font color="#990000">(</font><font color="#009900">void</font><font color="#990000">*</font> obj_<font color="#990000">,</font> <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font>Args<font color="#990000">...))</font> <b><font color="#0000FF">noexcept</font></b> <font color="#990000">:</font> obj_<font color="#FF0000">{</font>obj_<font color="#FF0000">}</font><font color="#990000">,</font> callback_<font color="#FF0000">{</font>callback_<font color="#FF0000">}</font> <font color="#FF0000">{}</font>
<b><font color="#0000FF">private</font></b><font color="#990000">:</font>
  <font color="#009900">void</font> <font color="#990000">*</font>obj_ <font color="#990000">=</font> nullptr<font color="#990000">;</font>
  <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font> <font color="#990000">*,</font> Args<font color="#990000">...)</font> <font color="#990000">=</font> nullptr<font color="#990000">;</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">class</font></b> <font color="#008080">R</font><font color="#990000">,</font> <b><font color="#0000FF">class</font></b><font color="#990000">...</font> Args<font color="#990000">&gt;</font> <b><font color="#0000FF">class</font></b> <font color="#008080">function_ref</font><font color="#990000">&lt;</font><b><font color="#000000">R</font></b><font color="#990000">(</font>Args<font color="#990000">...)</font> <b><font color="#0000FF">noexcept</font></b><font color="#990000">&gt;</font> <font color="#FF0000">{</font>
<b><font color="#0000FF">public</font></b><font color="#990000">:</font>
  <b><font color="#000000">function_ref</font></b><font color="#990000">(</font><font color="#009900">void</font><font color="#990000">*</font> obj_<font color="#990000">,</font> <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font><font color="#990000">*,</font>Args<font color="#990000">...))</font> <b><font color="#0000FF">noexcept</font></b> <font color="#990000">:</font> obj_<font color="#FF0000">{</font>obj_<font color="#FF0000">}</font><font color="#990000">,</font> callback_<font color="#FF0000">{</font>callback_<font color="#FF0000">}</font> <font color="#FF0000">{}</font>
<b><font color="#0000FF">private</font></b><font color="#990000">:</font>
  <font color="#009900">void</font> <font color="#990000">*</font>obj_ <font color="#990000">=</font> nullptr<font color="#990000">;</font>
  <b><font color="#000000">R</font></b> <font color="#990000">(*</font>callback_<font color="#990000">)(</font><font color="#009900">void</font> <font color="#990000">*,</font> Args<font color="#990000">...)</font> <b><font color="#0000FF">noexcept</font></b> <font color="#990000">=</font> nullptr<font color="#990000">;</font>
<font color="#FF0000">}</font><font color="#990000">;</font>
</tt></pre>

</div>
<p>All examples unless stated otherwise were compiled on <a href="https://www.godbolt.org/">godbolt.org</a> using "x86-64 clang (trunk)" with "-std=c++20 -O2" in order to identify dangling.</p>
<!--
<h3 id="function_ref-construction-usage">function_ref construction and usage</h3>
<h3 id="function_ref-stateless">free function and member function without type erasure use cases</h3>
-->
<p>In the following examples, function_ref is compared to std::function in order to identify it behaving unexpectedly. "function_ref" is also compared with itself to highlight inconsistencies in its own interface.</p>
<!-- function_ref-immediate-dangle.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><i><font color="#9A1900">//#include &lt;https://raw.githubusercontent.com/TartanLlama/function_ref/master/include/tl/function_ref.hpp&gt;</font></i>
<b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;https://raw.githubusercontent.com/descender76/cpp_proposals/main/function_ref/function_ref_prime.hpp&gt;</font>

<b><font color="#0000FF">struct</font></b> <font color="#008080">bar</font> <font color="#FF0000">{</font>
    <font color="#009900">void</font> <b><font color="#000000">baz</font></b><font color="#990000">()</font><font color="#FF0000">{}</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<font color="#009900">void</font> <b><font color="#000000">foo</font></b><font color="#990000">(</font>bar<font color="#990000">)</font> <font color="#FF0000">{</font>
<font color="#FF0000">}</font>

<font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    <font color="#008080">bar</font> b<font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr1 <font color="#990000">=</font> <font color="#990000">&amp;</font>bar<font color="#990000">::</font>baz<font color="#990000">;</font><i><font color="#9A1900">// immediately dangle</font></i>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr2 <font color="#990000">=</font> foo<font color="#990000">;</font><i><font color="#9A1900">// does not dangle</font></i>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> <font color="#990000">&amp;</font>foo<font color="#990000">;</font><i><font color="#9A1900">// immediately dangle</font></i>
    <i><font color="#9A1900">// the following behaves as expected</font></i>
    std<font color="#990000">::</font><font color="#008080">function&lt;void(bar)&gt;</font> fr4 <font color="#990000">=</font> <font color="#990000">&amp;</font>bar<font color="#990000">::</font>baz<font color="#990000">;</font>
    std<font color="#990000">::</font><font color="#008080">function&lt;void(bar)&gt;</font> fr5 <font color="#990000">=</font> foo<font color="#990000">;</font>
    std<font color="#990000">::</font><font color="#008080">function&lt;void(bar)&gt;</font> fr6 <font color="#990000">=</font> <font color="#990000">&amp;</font>foo<font color="#990000">;</font>
    <b><font color="#000000">fr1</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr2</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr4</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr5</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr6</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#0000FF">return</font></b> <font color="#993399">42</font><font color="#990000">;</font>
<font color="#FF0000">}</font></tt></pre>

</div>
<p>There are two things to note from the previous example. First, std::function works as expected in all three scenarios. The comparable function_ref has immediate dangling in two of the three. Second, when you compare function_ref to itself, there is a scenario where free function works but member function doesn't. This treats object oriented programming with less support than functional programming. Its been said that this is the incorrect usage of function_ref, in effect blaming the user instead of the specification and implementation. Those that believe such may give the following example as proof as it is ok to standardize something that can immediately dangle.</p>
<!-- string_view-immediate-dangle.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>std<font color="#990000">::</font><font color="#008080">string_view</font> sv <font color="#990000">=</font> <font color="#FF0000">"hello world"</font>s<font color="#990000">;</font>  <i><font color="#9A1900">// immediately dangling</font></i></tt></pre>

</div>
<p>While I normally would agree with such sentiment, in this scenario I whole heartedly disagree. Dangling occurs when you still have a reference to state that has gone out of scope, no longer exists. In this string_view example, it is clear that sv is a reference and ""s is state. It is totally unclear in the case of function_ref initialization. Dangling is not what the end user is intending on doing when a function is assigned whether free or member. Functions are stateless and also global, so they don't go out of scope. This implementation stores a free function pointer as the void* state of function_ref and because a member function pointer is larger than void* it is treated just like a capturing lambda or functor of size greater than a void*. In essence, implementation details are bleeding through function_ref's public interface and effecting how users are to use function_ref. The current function_ref specification is currently silent on how implementations should behave and how end users should consume in light of its differences with std::function.</p>
<p>Another example given by the current proponents of function_ref is how the users of function_ref should fix the dangling.</p>
<!-- function_ref-dangling-corrected-by-user.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><i><font color="#9A1900">//#include &lt;https://raw.githubusercontent.com/TartanLlama/function_ref/master/include/tl/function_ref.hpp&gt;</font></i>
<b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;https://raw.githubusercontent.com/descender76/cpp_proposals/main/function_ref/function_ref_prime.hpp&gt;</font>

<b><font color="#0000FF">struct</font></b> <font color="#008080">bar</font> <font color="#FF0000">{</font>
    <font color="#009900">void</font> <b><font color="#000000">baz</font></b><font color="#990000">()</font><font color="#FF0000">{}</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<font color="#009900">void</font> <b><font color="#000000">foo</font></b><font color="#990000">(</font>bar<font color="#990000">)</font> <font color="#FF0000">{</font>
<font color="#FF0000">}</font>

<font color="#009900">void</font> <b><font color="#000000">correct_usage_of_current_function_ref</font></b><font color="#990000">(</font>tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt; fr1, tl::function_ref&lt;void(bar)&gt;</font> fr2<font color="#990000">)</font> <font color="#FF0000">{</font>
    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr1</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr2</font></b><font color="#990000">(</font>b<font color="#990000">);</font>    
<font color="#FF0000">}</font>

<font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    <b><font color="#0000FF">auto</font></b> temp <font color="#990000">=</font> <font color="#990000">&amp;</font>bar<font color="#990000">::</font>baz<font color="#990000">;</font><i><font color="#9A1900">// WORKAROUND</font></i>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr1 <font color="#990000">=</font> temp<font color="#990000">;</font>
    <b><font color="#0000FF">auto</font></b> temp <font color="#990000">=</font> <font color="#990000">&amp;</font>foo<font color="#990000">;</font><i><font color="#9A1900">// WORKAROUND</font></i>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr2 <font color="#990000">=</font> temp<font color="#990000">;</font>
    <font color="#008080">bar</font> b<font color="#990000">;</font>
    <b><font color="#000000">fr1</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr2</font></b><font color="#990000">(</font>b<font color="#990000">);</font>    

    <b><font color="#000000">correct_usage_of_current_function_ref</font></b><font color="#990000">(&amp;</font>foo<font color="#990000">,</font> <font color="#990000">&amp;</font>bar<font color="#990000">::</font>baz<font color="#990000">);</font>
    <b><font color="#0000FF">return</font></b> <font color="#993399">42</font><font color="#990000">;</font>
<font color="#FF0000">}</font></tt></pre>

</div>
<p><!--Where is this usage specified in the specification?-->Some proponents of the current function_ref proposal advocate for not even messing with the WORKAROUND which is sort of how one currently deals with dangling today and that the correct usage is to just initialize the function_ref directly in the function parameter in question. I would argue that we should still be able to initialize first because I may provide the same function_ref instantiation to multiple parameters across multiple function calls. Otherwise, duplicating an exact same lambda, in more complicated scenarios, would increase verbosity and violating in programming the one definition rule or don't repeat yourself. This usage is also plagued with the superfluous workaround line. Why initialize with 2 lines of code when it should just be one! Again, it is not like std::function or how we initialize in C++. Why force end users to work around dangling needlessly when the library implementation is more than capable of handling this? By fixing these trivial dangling noise, we leave the remaining dangling cases to be as clear as the std::string_view example. So, how do we fix some of this dangling in the implementation!</p>
<!--
<h3 id="reference-power">the true power of the reference side</h3>
-->
<p>Given the new constructor mentioned in the "<a href="#overview">Overview</a>" we can construct an example that does not dangle.</p>
<!-- function_ref-dangling-corrected-by-user2.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><i><font color="#9A1900">//#include &lt;https://raw.githubusercontent.com/TartanLlama/function_ref/master/include/tl/function_ref.hpp&gt;</font></i>
<b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;https://raw.githubusercontent.com/descender76/cpp_proposals/main/function_ref/function_ref_prime.hpp&gt;</font>

<b><font color="#0000FF">struct</font></b> <font color="#008080">bar</font> <font color="#FF0000">{</font>
    <font color="#009900">void</font> <b><font color="#000000">baz</font></b><font color="#990000">()</font><font color="#FF0000">{}</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<font color="#009900">void</font> <b><font color="#000000">foo</font></b><font color="#990000">(</font>bar<font color="#990000">)</font> <font color="#FF0000">{</font>
<font color="#FF0000">}</font>

<font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr1 <font color="#990000">=</font> <font color="#990000">&amp;</font>bar<font color="#990000">::</font>baz<font color="#990000">;</font><i><font color="#9A1900">// immediately dangle</font></i>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr2 <font color="#990000">=</font> <font color="#990000">&amp;</font>foo<font color="#990000">;</font><i><font color="#9A1900">// immediately dangle</font></i>
    <i><font color="#9A1900">// no dangling, this proposal via new constructor</font></i>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr3 <font color="#990000">=</font> <font color="#FF0000">{</font>nullptr<font color="#990000">,</font> <font color="#990000">[](</font><font color="#009900">void</font><font color="#990000">*,</font> <font color="#008080">bar</font> b<font color="#990000">)</font><font color="#FF0000">{</font>b<font color="#990000">.</font><b><font color="#000000">baz</font></b><font color="#990000">();</font><font color="#FF0000">}}</font><font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr4 <font color="#990000">=</font> <font color="#FF0000">{</font>nullptr<font color="#990000">,</font> <font color="#990000">[](</font><font color="#009900">void</font><font color="#990000">*,</font> <font color="#008080">bar</font> b<font color="#990000">)</font><font color="#FF0000">{</font><b><font color="#000000">foo</font></b><font color="#990000">(</font>b<font color="#990000">);</font><font color="#FF0000">}}</font><font color="#990000">;</font>
    <i><font color="#9A1900">// no dangling, original proposal via stateless lambda</font></i>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr5 <font color="#990000">=</font> <font color="#990000">[](</font><font color="#008080">bar</font> b<font color="#990000">)</font><font color="#FF0000">{</font>b<font color="#990000">.</font><b><font color="#000000">baz</font></b><font color="#990000">();</font><font color="#FF0000">}</font><font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar)&gt;</font> fr6 <font color="#990000">=</font> <font color="#990000">[](</font><font color="#008080">bar</font> b<font color="#990000">)</font><font color="#FF0000">{</font><b><font color="#000000">foo</font></b><font color="#990000">(</font>b<font color="#990000">);</font><font color="#FF0000">}</font><font color="#990000">;</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>

    <b><font color="#000000">fr1</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr2</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr4</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr5</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr6</font></b><font color="#990000">(</font>b<font color="#990000">);</font>

    <b><font color="#0000FF">return</font></b> <font color="#993399">42</font><font color="#990000">;</font>
<font color="#FF0000">}</font></tt></pre>

</div>
<p>This set of examples shows how free function and member function without type erasure use cases can be handled without any dangling and without the syntax of having to put function_ref initialization parameter on a seperate temporary line. The pair of examples that uses the new constructor is clear that their is no dangling because their is no state, both by the nullptr and the lambda used doesn't capture i.e. stateless. Similarly, the lambda examples that uses the current function_ref constructor is similarly non capturing, stateless. The problem with these two solutions is the lack of clarity because we can't simply assign a function with a known compatible signature. This means we have [], (), forwarded aparmeters and possibly return statement. The new constructor examples are also not type safe, though in a stateless scenario, that is a little less of an issue. However, by nailing down the specification and providing the new constructor, we can do much better. Using the new constructor, "make_function_ref" factory functions can be created that type safely creates function_ref from member or free functions without any dangling.</p>
<!-- make_function_ref-stateless.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><i><font color="#9A1900">//#include &lt;https://raw.githubusercontent.com/TartanLlama/function_ref/master/include/tl/function_ref.hpp&gt;</font></i>
<b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;https://raw.githubusercontent.com/descender76/cpp_proposals/main/function_ref/function_ref_prime.hpp&gt;</font>

<b><font color="#0000FF">struct</font></b> <font color="#008080">bar</font> <font color="#FF0000">{</font>
    <font color="#009900">void</font> <b><font color="#000000">baz</font></b><font color="#990000">()</font><font color="#FF0000">{}</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<font color="#009900">void</font> <b><font color="#000000">foo</font></b><font color="#990000">(</font>bar<font color="#990000">&amp;)</font> <font color="#FF0000">{</font>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// side by side examples</font></i>
<font color="#009900">void</font> <b><font color="#000000">examples</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar&amp;)&gt;</font> fr1 <font color="#990000">=</font> <font color="#FF0000">{</font>nullptr<font color="#990000">,</font> <font color="#990000">[](</font><font color="#009900">void</font><font color="#990000">*,</font> bar<font color="#990000">&amp;</font> b<font color="#990000">)</font><font color="#FF0000">{</font>b<font color="#990000">.</font><b><font color="#000000">baz</font></b><font color="#990000">();</font><font color="#FF0000">}}</font><font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar&amp;)&gt;</font> fr2 <font color="#990000">=</font> <font color="#FF0000">{</font>nullptr<font color="#990000">,</font> <font color="#990000">[](</font><font color="#009900">void</font><font color="#990000">*,</font> bar<font color="#990000">&amp;</font> b<font color="#990000">)</font><font color="#FF0000">{</font><b><font color="#000000">foo</font></b><font color="#990000">(</font>b<font color="#990000">);</font><font color="#FF0000">}}</font><font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar&amp;)&gt;</font> fr3 <font color="#990000">=</font> <font color="#990000">[](</font>bar<font color="#990000">&amp;</font> b<font color="#990000">)</font><font color="#FF0000">{</font>b<font color="#990000">.</font><b><font color="#000000">baz</font></b><font color="#990000">();</font><font color="#FF0000">}</font><font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar&amp;)&gt;</font> fr4 <font color="#990000">=</font> <font color="#990000">[](</font>bar<font color="#990000">&amp;</font> b<font color="#990000">)</font><font color="#FF0000">{</font><b><font color="#000000">foo</font></b><font color="#990000">(</font>b<font color="#990000">);</font><font color="#FF0000">}</font><font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar&amp;)&gt;</font> fr5 <font color="#990000">=</font> tl<font color="#990000">::</font>make_function_ref<font color="#990000">&lt;</font>foo<font color="#990000">&gt;();</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar&amp;)&gt;</font> fr6 <font color="#990000">=</font> tl<font color="#990000">::</font>make_function_ref<font color="#990000">&lt;&amp;</font>foo<font color="#990000">&gt;();</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void(bar&amp;)&gt;</font> fr7 <font color="#990000">=</font> tl<font color="#990000">::</font>make_function_ref<font color="#990000">&lt;&amp;</font>bar<font color="#990000">::</font>baz<font color="#990000">&gt;();</font>

    <font color="#008080">bar</font> b<font color="#990000">;</font>

    <b><font color="#000000">fr1</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr2</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr4</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr5</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr6</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
    <b><font color="#000000">fr7</font></b><font color="#990000">(</font>b<font color="#990000">);</font>
<font color="#FF0000">}</font>

<font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    <b><font color="#0000FF">return</font></b> <font color="#993399">42</font><font color="#990000">;</font>
<font color="#FF0000">}</font></tt></pre>

</div>
<p>These make_function_ref examples provides the best of both worlds. No dangling for member and free functions without type erasure and a reasonably concise syntax that explicitly states what the user intends to do.</p>
<!--
<h3 id="function_ref-construction-missing">the missing function_ref construction use cases</h3>
-->
<p>Adding the new constructor, mentioned in the "<a href="#overview">Overview</a>", makes the implementation of function_ref capable of so much more functionality then is currently available. The current function_ref implentation only type erases state for callables such as capturing lambdas but what if your functions or member functions could benefit from type erasure. Instead of making these latter two use cases easy, current users have to use a lambda even if there were no changes in their callable parameters. This too can be improved. Using the new constructor, "make_function_ref" factory functions can be created that type safely creates function_ref from member or free functions with type erased state, as is common in both functional and object oriented programming. Since the usage of these factory functions are intended for objects that already exist, than in this scenario too there is significantly less dangling that a user has to deal with.</p>
<!--
<h3 id="function_ref-stateful">free function and member function with type erasure use cases</h3>
-->
<!-- make_function_ref-stateful.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><i><font color="#9A1900">//#include &lt;https://raw.githubusercontent.com/TartanLlama/function_ref/master/include/tl/function_ref.hpp&gt;</font></i>
<b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;https://raw.githubusercontent.com/descender76/cpp_proposals/main/function_ref/function_ref_prime.hpp&gt;</font>

<b><font color="#0000FF">struct</font></b> <font color="#008080">bar</font> <font color="#FF0000">{</font>
    <font color="#009900">void</font> <b><font color="#000000">baz</font></b><font color="#990000">()</font><font color="#FF0000">{}</font>
    <font color="#009900">void</font> <b><font color="#0000FF">operator</font></b><font color="#990000">()()</font><font color="#FF0000">{}</font>
<font color="#FF0000">}</font><font color="#990000">;</font>

<font color="#009900">void</font> <b><font color="#000000">foo</font></b><font color="#990000">(</font>bar<font color="#990000">&amp;)</font> <font color="#FF0000">{</font>
<font color="#FF0000">}</font>

<i><font color="#9A1900">// side by side examples</font></i>
<font color="#009900">void</font> <b><font color="#000000">examples</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    <font color="#008080">bar</font> b<font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr1 <font color="#990000">=</font> <font color="#990000">[&amp;</font>b<font color="#990000">]()</font><font color="#FF0000">{</font>b<font color="#990000">.</font><b><font color="#000000">baz</font></b><font color="#990000">();</font><font color="#FF0000">}</font><font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr2 <font color="#990000">=</font> <font color="#990000">[&amp;</font>b<font color="#990000">]()</font><font color="#FF0000">{</font><b><font color="#000000">foo</font></b><font color="#990000">(</font>b<font color="#990000">);</font><font color="#FF0000">}</font><font color="#990000">;</font>
    <i><font color="#9A1900">// using the new constructor</font></i>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr3 <font color="#990000">=</font> <font color="#FF0000">{</font><font color="#990000">&amp;</font>b<font color="#990000">,</font> <font color="#990000">[](</font><font color="#009900">void</font><font color="#990000">*</font> obj<font color="#990000">)</font><font color="#FF0000">{</font><b><font color="#0000FF">static_cast</font></b><font color="#990000">&lt;</font>bar<font color="#990000">*&gt;(</font>obj<font color="#990000">)-&gt;</font><b><font color="#000000">baz</font></b><font color="#990000">();</font><font color="#FF0000">}}</font><font color="#990000">;</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr4 <font color="#990000">=</font> <font color="#FF0000">{</font><font color="#990000">&amp;</font>b<font color="#990000">,</font> <font color="#990000">[](</font><font color="#009900">void</font><font color="#990000">*</font> obj<font color="#990000">)</font><font color="#FF0000">{</font><b><font color="#000000">foo</font></b><font color="#990000">(*</font><b><font color="#0000FF">static_cast</font></b><font color="#990000">&lt;</font>bar<font color="#990000">*&gt;(</font>obj<font color="#990000">));</font><font color="#FF0000">}}</font><font color="#990000">;</font>
    <i><font color="#9A1900">// using make_function_ref which uses new constructor</font></i>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr5 <font color="#990000">=</font> tl<font color="#990000">::</font>make_function_ref<font color="#990000">&lt;</font>foo<font color="#990000">&gt;(</font>b<font color="#990000">);</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr6 <font color="#990000">=</font> tl<font color="#990000">::</font>make_function_ref<font color="#990000">&lt;&amp;</font>foo<font color="#990000">&gt;(</font>b<font color="#990000">);</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr7 <font color="#990000">=</font> tl<font color="#990000">::</font>make_function_ref<font color="#990000">&lt;&amp;</font>bar<font color="#990000">::</font>baz<font color="#990000">&gt;(</font>b<font color="#990000">);</font>
    tl<font color="#990000">::</font><font color="#008080">function_ref&lt;void()&gt;</font> fr8 <font color="#990000">=</font> tl<font color="#990000">::</font>make_function_ref<font color="#990000">&lt;&amp;</font>bar<font color="#990000">::</font><b><font color="#0000FF">operator</font></b><font color="#990000">()&gt;(</font>b<font color="#990000">);</font>
    <i><font color="#9A1900">// C#</font></i>
    <i><font color="#9A1900">// delegate void some_name();</font></i>
    <i><font color="#9A1900">// some_name fr = foo;</font></i>
    <i><font color="#9A1900">// some_name fr = b.baz;</font></i>
    <i><font color="#9A1900">///////////////////////////////</font></i>
    <i><font color="#9A1900">// Borland C++, embarcadero __closure</font></i>
    <i><font color="#9A1900">// void(__closure * fr)();</font></i>
    <i><font color="#9A1900">// fr = foo</font></i>
    <i><font color="#9A1900">// fr = b.baz</font></i>

    <b><font color="#000000">fr1</font></b><font color="#990000">();</font>
    <b><font color="#000000">fr2</font></b><font color="#990000">();</font>
    <b><font color="#000000">fr3</font></b><font color="#990000">();</font>
    <b><font color="#000000">fr4</font></b><font color="#990000">();</font>
    <b><font color="#000000">fr5</font></b><font color="#990000">();</font>
    <b><font color="#000000">fr6</font></b><font color="#990000">();</font>
    <b><font color="#000000">fr7</font></b><font color="#990000">();</font>
    <b><font color="#000000">fr8</font></b><font color="#990000">();</font>
<font color="#FF0000">}</font>

<font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
    <b><font color="#0000FF">return</font></b> <font color="#993399">42</font><font color="#990000">;</font>
<font color="#FF0000">}</font></tt></pre>

</div>
<p>Here, the type erased free and member function use cases are consistent with the free and member use cases that do not have type erasure. It is concise. Conveys the intent of the user and provides a feature found in other proramming languages that C++ users have been clamoring for decades. There is an additional reason that goes to ease of use. When you use a stateful lambda to needlessly tie the type erased state to a method, you are in essence creating a new anonymous type and instance which has its own lifetime that must be managed by the user. Superflous code is being added which the optimizer has to remove. Usage of function_ref becomes harder to reason about. You in essense have a function_ref which is a reference, refering to a lambda which is a reference that references the actual object in question. This makes it harder to reason about any remaining dangling. A reference to a reference is not a reference. It is rather a pointer which has multiple levels of indirection. A reference was always a collapsable single level of indirection.</p>
<h2 id="ftm">Feature test macro</h2>
<p>We do not need a feature macro, because we intend for this paper to modify std::function_ref before it ships.</p>
<h2 id="other-languages">Other Languages</h2>
<p>C# and the .NET family of languages provide this via delegates.</p>
<!-- other-language-c-sharp.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><i><font color="#9A1900">// C#</font></i>
delegate <font color="#008080">void</font> <b><font color="#000000">some_name</font></b><font color="#990000">();</font>
<font color="#008080">some_name</font> fr <font color="#990000">=</font> foo<font color="#990000">;</font><i><font color="#9A1900">// the stateless free function use case</font></i>
<font color="#008080">some_name</font> fr <font color="#990000">=</font> b<font color="#990000">.</font>baz<font color="#990000">;</font><i><font color="#9A1900">// the stateful member function use case</font></i></tt></pre>

</div>
<p>Borland C++ now embarcadero provide this via __closure.</p>
<!-- other-language-borland-cpp.cc.html -->
<div class="code">
<!-- Generator: GNU source-highlight 3.1.9
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><i><font color="#9A1900">// Borland C++, embarcadero __closure</font></i>
<font color="#009900">void</font><font color="#990000">(</font>__closure <font color="#990000">*</font> fr<font color="#990000">)();</font>
fr <font color="#990000">=</font> foo<font color="#990000">;</font><i><font color="#9A1900">// the stateless free function use case</font></i>
fr <font color="#990000">=</font> b<font color="#990000">.</font>baz<font color="#990000">;</font><i><font color="#9A1900">// the stateful member function use case</font></i></tt></pre>

</div>
<p>Since make_function_ref handles all 4 statess/stateful free/member use cases, it is more feature rich than either of the above.</p>
<h2 id="implementation">Example implementation</h2>
<p>The most up-to-date implementation, created by Jarrad Waterloo, is available on <a href="#make_function_ref-implementation">Github</a></p>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>Thanks to Arthur O'Dwyer, Tomasz Kamiński and Corentin Jabot for providing very valuable feedback on <!--earlier drafts of--> this proposal.</p>
<h2 id="alternative">Annex: alternative design decisions</h2>
<h3 id="auto">Why not just use [&b](auto... args){b.baz(args...);}?</h3>
<p>While succinct, this does have some undesirable consequences.</p>
<ul>
<li>It is more complex; at least cognitively speaking. The only pieces the end user really cares about is either "=baz" or "=b.baz". The capture, the parameter propagation even with auto and the occassional return are all superfluous.</li>
<li>If this was a C function pointer would the end user be happy with that versus just assigning with "= some_function". In this case the public wrapper interface is more complicated than the internals. Shouldn't that be reversed i.e. abstraction.</li>
<li>Using a functor or stateful lambda does require creating a object and type even if anonymous that has a lifetime that must be managed making things more complicated.</li>
<li>Construction which should be one step has now been broken into two which is more cumbersome; see the next decision.</li>
</ul>
<h3 id="general-purpose-callable-library">Why not just use bind_front and turn the remaining make_function_ref implementations into a general purpose functors library?</h3>
<p>I actually agree that C++ could use a separate function transformation library for the general cases but I don't think that should negate function_ref supporting compatible signatures; i.e. first class support. Such a general purpose library would turn what should be a one step construction process into a two step process; first create a functor and then assign it to the function_ref. Personally I prefer one step and here is why. function_ref is to function pointer, in C, as std::array is to C/C++ array. It is more intuitive/familiar to the end user. a function pointer is simply assigned for compatible/comparable signatures and the end user must create a new function for incompatible signatures in order to do conversions or reordering of parameters and in the case of functors, adding more parameters. This two phase construction is more verbose. make_function_ref is less so and the same name regardless of what is being assigned. It is also similar to make_pair, make_shared_ptr and the other single step make functions; again familiar. I would hesitate to say that end users expect a simple construction methodology based on the prevalence of simpler solutions in other languages and there is no good reason why we should make things deliberately harder especially for common cases when it is not needed to be so.</p>
<p>It should also be noted that their are current C++ limitations that restrict our implementation choices.</p>
<ul>
<li>C++ template constructors do not support explicit template parameters meaning having to resort to tag classes which make things more verbose.</li>
<li>Template functions do not support partial specialization meaning such things that should simply be performed by functions has to be performed by whole partially specialized classes making things more verbose.</li>
<li>Making heavily templatized make_function_ref functions into FRIEND functions of function_ref is borderline impossible, if not so. This is why I still need my public double pointer constructor. I am still for having this constructor anyway for advance end users to prototype other compatible signatures for operators and other function like constructs in C++ that currently don't have a natural binding.</li>
</ul>
<p>At present, my current make_function_ref solution seems to provide a very concise single step construction that enhances function_ref to support better the 4 use cases: [non] type erased [member/free] functions.</p>
<h2 id="references">References</h2>
<span id="reference-p0792r5">[P0792R5] function_ref: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r5.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r5.html</a><br/>
<br/>
<span id="reference-github">function_ref</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://github.com/TartanLlama/function_ref" target="__blank">https://github.com/TartanLlama/function_ref</a><br/>
<br/>
<span id="make_function_ref-implementation">make_function_ref implementation</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://raw.githubusercontent.com/descender76/cpp_proposals/main/function_ref/function_ref_prime.hpp" target="__blank">https://raw.githubusercontent.com/descender76/cpp_proposals/main/function_ref/function_ref_prime.hpp</a><br/>
<br/>
<span id="reference-delegate">Using Delegates (C# Programming Guide)</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/using-delegates" target="__blank">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/using-delegates</a><br/>
<br/>
<span id="reference-closure">__closure</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://docwiki.embarcadero.com/RADStudio/Sydney/en/Closure" target="__blank">http://docwiki.embarcadero.com/RADStudio/Sydney/en/Closure</a><br/>
<br/>
<span id="reference-fastest">Member Function Pointers and the Fastest Possible C++ Delegates</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible" target="__blank">https://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible</a><br/>
<br/>
<span id="reference-fast">The Impossibly Fast C++ Delegates</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates" target="__blank">https://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates</a><br/>
<br/>
<span id="reference-impossibly">Impossibly fast delegate in C++11</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://codereview.stackexchange.com/questions/14730/impossibly-fast-delegate-in-c11" target="__blank">https://codereview.stackexchange.com/questions/14730/impossibly-fast-delegate-in-c11</a><br/>
<br/>
<span id="reference-dyno">Dyno: Runtime polymorphism done right</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://github.com/ldionne/dyno" target="__blank">https://github.com/ldionne/dyno</a><br/>
<br/>
<span id="reference-te">[Boost::ext].TE</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://github.com/boost-ext/te" target="__blank">https://github.com/boost-ext/te</a><br/>
<br/>
</body>
</html>
