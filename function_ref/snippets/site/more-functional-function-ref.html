<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>A More Functional function_ref</title>
  <meta name="description" content="A More Functional function_ref">
  <meta name="author" content="Jarrad Waterloo">
  <style>
    h1
	{
	  text-align : center;
	}
	.code
	{
	  background-color: AliceBlue;
	}
	table.inline_references
	{
		border: 1px solid black;
		border-collapse: collapse;
	}
	table.inline_references > thead > tr > th
	{
		border: 1px solid black;
	}
	table.inline_references > tbody > tr > td
	{
		border: 1px solid black;
	}
	.problem
	{
		font-weight : bold;
		color : red;
	}
	/*
	*/
  </style>
</head>
<body>
<h1>A More Functional function_ref</h1>
<table style="width:100%">
<tr>
<td>&nbsp;</td>
<td style="width:60ex">
  <table>
  <tr>
  <td><b>Document #:</b></td><td>PTODOR0</td>
  </tr>
  <tr>
  <td><b>Date:</b></td><td>2021-07-30</td>
  </tr>
  <tr>
  <td><b>Project:</b></td><td>Programming Language C++</td>
  </tr>
  <tr>
  <td><b>Audience:</b></td><td>Library Evolution Working Group (LEWG)</td>
  </tr>
  <tr>
  <td><b>Reply-to:</b></td><td>Jarrad J. Waterloo<br/>&lt;<a href="mailto:descender76@gmail.com">descender76@gmail.com</a>&gt;</td>
  </tr>
  </table>
</td>
</tr>
</table>
<h2>Contents</h2>
<!--
<h3><a href="#revision_history">1&nbsp;&nbsp;Revision History</a></h3>
-->
<h3><a href="#introduction">1&nbsp;&nbsp;Introduction</a></h3>
<h3><a href="#history_prior_work">2&nbsp;&nbsp;History &amp; Prior Work</a></h3>
<h3><a href="#fall_short">4&nbsp;&nbsp;Where does function_ref fall short?</a></h3>
<h3><a href="#alternate_realities">5&nbsp;&nbsp;Solutions &amp; Alternate Realities</a></h3>
<!--
<h3><a href="#motivation_scope">2&nbsp;&nbsp;Motivation and Scope</a></h3>
<h3><a href="#before_after">3&nbsp;&nbsp;Before/After Comparisons</a></h3>
<h3><a href="#overview">4&nbsp;&nbsp;Design Overview</a></h3>
<h3><a href="#wording">5&nbsp;&nbsp;Proposed Wording</a></h3>
<h3><a href="#design">7&nbsp;&nbsp;Design Decisions</a></h3>
-->
<h3><a href="#performance">6&nbsp;&nbsp;Runtime Performance</a></h3>
<!--
<h3><a href="#examples">9&nbsp;&nbsp;Examples</a></h3>
<h3><a href="#future">10&nbsp;Future Work</a></h3>
<h3><a href="#acknowledgements">11&nbsp;Acknowledgements</a></h3>
-->
<h3><a href="#references">7&nbsp;&nbsp;References</a></h3>
<!--
<h2 id="revision_history">Revision History</h2>
<p>TODO</p>
-->
<h2 id="introduction">Introduction</h2>
<p>There are many types of runtime polymorphism each with their PRO's and CON's. These range from single function callbacks to classes with multiple virtual member functions and even those with multiple type erased parameters. Even though C gives us callbacks via function pointers and C++ adds to our support of runtime polymorphism via its virtual functions, their is still considerable interest in other types of runtime polymorphism, as illustrated by just some of the proposals in past years.</p>
<table class="inline_references">
<thead>
<tr>
<th>Document Date</th>
<th>WG21 Number</th>
<th>Title</th>
<th>Author</th>
</tr>
</thead>
<tr>
<td>2017-02-06</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0288r1.pdf">P0288R1</a></td>
<td>A polymorphic wrapper for all Callable objects</td>
<td>David Krauss</td>
</tr>
<tr>
<td><i>2017-06-07</i></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0312r1.html"><i>P0312R1</i></a></td>
<td><i>Make Pointers to Members Callable</i></td>
<td><i>Barry Revzin</i></td>
</tr>
<tr>
<td>2017-10-16</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0201r2.pdf">P0201R2</a></td>
<td>A polymorphic value-type for C++</td>
<td>Jonathan Coe</td>
</tr>
<tr>
<td><b>2017-10-10</b></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0792r0.html"><b>P0792R0</b></a></td>
<td><b>function_ref: a non-owning reference to a Callable</b></td>
<td><b>Vittorio Romeo</b></td>
</tr>
<td>2018-02-12</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0201r3.pdf">P0201R3</a></td>
<td>A polymorphic value-type for C++</td>
<td>Jonathan Coe, Sean Parent</td>
</tr>
<tr>
<td><b>2017-11-26</b></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r1.html"><b>P0792R1</b></a></td>
<td><b>function_ref: a non-owning reference to a Callable</b></td>
<td><b>Vittorio Romeo</b></td>
</tr>
<tr>
<td>2018-02-12</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0957r0.pdf">P0957R0</a></td>
<td>PFA: A Generic, Extendable and Efficient Solution for Polymorphic Programming</td>
<td>Mingxin Wang</td>
</tr>
<tr>
<td><i>2018-04-01</i></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0984r0.pdf"><i>P0984R0</i></a></td>
<td><i>All (*)()-Pointers Replaced by Ideal Lambdas</i></td>
<td><i>Peter Sommerlad</i></td>
</tr>
<tr>
<td><b>2018-05-06</b></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r2.html"><b>P0792R2</b></a></td>
<td><b>function_ref: a non-owning reference to a Callable</b></td>
<td><b>Vittorio Romeo</b></td>
</tr>
<tr>
<td>2018-04-18</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0957r1.pdf">P0957R1</a></td>
<td>PFA: A Generic, Extendable and Efficient Solution for Polymorphic Programming</td>
<td>Mingxin Wang</td>
</tr>
<tr>
<td>2018-10-05</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0201r4.pdf">P0201R4</a></td>
<td>A polymorphic value-type for C++</td>
<td>Jonathan Coe, Sean Parent</td>
</tr>
<tr>
<td><b>2018-10-07</b></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r3.html"><b>P0792R3</b></a></td>
<td><b>function_ref: a non-owning reference to a Callable</b></td>
<td><b>Vittorio Romeo</b></td>
</tr>
<tr>
<td><i>2018-10-06</i></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1214r0.html"><i>P1214R0</i></a></td>
<td><i>Pointer to Member Functions and Member Objects are just Callables!</i></td>
<td><i>JeanHeyd Meneide</i></td>
</tr>
<td>2019-03-11</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0201r5.html">P0201R5</a></td>
<td>A polymorphic value-type for C++</td>
<td>Jonathan Coe, Sean Parent</td>
</tr>
<tr>
<td><b>2019-06-17</b></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r4.html"><b>P0792R4</b></a></td>
<td><b>function_ref: a non-owning reference to a Callable</b></td>
<td><b>Vittorio Romeo</b></td>
</tr>
<tr>
<td>2019-06-17</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0957r2.pdf">P0957R2</a></td>
<td>PFA: A Generic, Extendable and Efficient Solution for Polymorphic Programming</td>
<td>Mingxin Wang</td>
</tr>
<tr>
<td>2019-06-17</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1678r0.pdf">P1678R0</a></td>
<td>Callbacks and Composition</td>
<td>Kirk Shoop</td>
</tr>
<tr>
<td>2019-08-05</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1678r1.pdf"></a>P1678R1</td>
<td>Callbacks and Composition</td>
<td>Kirk Shoop</td>
</tr>
<tr>
<td>2019-10-07</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0288r5.html">P0288R5</a></td>
<td>any_invocable</td>
<td>Matt Calabrese, Ryan McDougall</td>
</tr>
<tr>
<td><b>2019-10-06</b></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r5.html"><b>P0792R5</b></a></td>
<td><b>function_ref: a non-owning reference to a Callable</b></td>
<td><b>Vittorio Romeo</b></td>
</tr>
<tr>
<td>2019-10-07</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0957r3.pdf">P0957R3</a></td>
<td>PFA: A Generic, Extendable and Efficient Solution for Polymorphic Programming</td>
<td>Mingxin Wang</td>
</tr>
<tr>
<td>2019-10-06</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1678r2.pdf">P1678R2</a></td>
<td>Callbacks and Composition</td>
<td>Kirk Shoop</td>
</tr>
<tr>
<td>2019-11-23</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0957r4.pdf">P0957R4</a></td>
<td>PFA: A Generic, Extendable and Efficient Solution for Polymorphic Programming</td>
<td>Mingxin Wang</td>
</tr>
<tr>
<td>2020-03-04</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2123r0.html">P2123R0</a></td>
<td>interfaces: A Facility to Manage ABI/API Evolution</td>
<td>Hal Finkel, Tom Scogland</td>
</tr>
</table>
<p>One such is the single function callback as proposed in the <a href="#reference-p0792r5">function_ref</a> proposals. Upon closer examination, function_ref has some serious limitations and does not handle a common use case. In order to better understand these limitations and the common use case we need to examine callbacks historically and the prior work of others.</p>
<h2 id="history_prior_work">History &amp; Prior Work</h2>
<p><a href="#reference-p0792r5">function_ref</a> is most like <a href="#reference-cpp-pointer-declaration-function">C function pointers</a>. In the following modified <a href="#reference-cpp-pointer-declaration-function">cppreference</a> example, int_return_int is  the type of function pointer that points to function that takes and returns an int.</p>
<!-- snippet-function-pointer-simple.cc.html -->
<div class="code">
{{> snippets/snippet-function-pointer-simple.cc}}
</div>
<p>While C function pointers are generally useful they can be temporarily limiting because the behavior of the provided function varies on the parameters passed by the caller of function pointer and not by the provider of the function. This limit is surpassed with a little bit of colaboration between the caller and the provider of the function by making a slight modification to the function pointer type signature that they agree to. Adding a void* to the parameter list of function pointer allows the provider of the to be called function to provide type erased state to influence the desired behavior of the function, provided of course the caller passes this state along.</p>
<!-- snippet-function-pointer-complex.cc.html -->
<div class="code">
{{> snippets/snippet-function-pointer-complex.cc}}
</div>
<p>Taking it a step forward the function pointer and the type erased user data can be combined since they are tightly related because they both come from the same provider.</p>
<!-- snippet-function-pointer-struct.cc.html -->
<div class="code">
{{> snippets/snippet-function-pointer-struct.cc}}
</div>
<p>Interesting this is comparable to how function_ref was <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r5.html#cb9-6" target="__blank">designed</a> and/or <a href="https://github.com/TartanLlama/function_ref/blob/master/include/tl/function_ref.hpp#L196" target="__blank">implemented</a>.</p>
<h3>Design</h3>
<p>Notice the type erased object. Notice also that the specification doesn't mention the type erased parameter passed to the "erased_function". (Just an oversight I guess.)</p>
<!-- snippet-function_ref-private-spec.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-private-spec.cc}}
</div>
<h3>Implementation</h3>
<p>Notice the type erased object and how it is passed to the function pointer.</p>
<!-- snippet-function_ref-private-impl.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-private-impl.cc}}
</div>
<p>So function_ref represents a subset of C function pointers where state specific to the implemented function may be passed along with it. "function_ref" makes working with these highly useful type erased callbacks safer because it ensures that the right state is bound to a compatible function and also that the caller actually passes along said state. "function_ref" is as essential to C++ as function pointers are to C in providing the ability to pass and return functions from functions for <a href="https://en.wikipedia.org/wiki/Functional_programming#First-class_and_higher-order_functions" target="__blank">functional programming<a>. "function_ref", once refined, is also important because it fixes a pseudo-mistake in C++ caused by bifurcation when adding new features to the language and in this case during the standardization process.</p>
<p><span class="problem">Function pointers are not the same in C as they are in C++</span>, even though C++ is somewhat a superset of C, at least in the case when it comes to support for C function pointers.</b>
<p>I am not talking about member function pointers, that is a whole other beast<!--subject-->. In C, int (*)(int) can point to <b>ANY</b> function that takes a int and returns an int. That is both easy and very useful. In C++, a "C" function pointer can not point to a constructor, a destructor, an operator or a member function without having to create binders i.e. translation functions. By adding constructors, destructors, operators and member functions to the language a manifold bifurcation ensued especially since there was no implicit or explicit conversions of the new language constructs to the prior language feature of function pointers. What was once easy is now tedious! C function pointers in C++ is like swiss cheese.</p>
<a href="https://freesvg.org/swiss-cheese" target="__blank">
<svg style="shape-rendering:geometricPrecision;text-rendering:geometricPrecision;image-rendering:optimizeQuality" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" xml:space="preserve" height="130.64mm" width="177.46mm" version="1.1" clip-rule="evenodd" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 17746 13064">
 <defs>
  <style type="text/css">
   <![CDATA[
    .fil3 {fill:#FEFEFE}
    .fil4 {fill:#FFF688}
    .fil0 {fill:#FCF4A7}
    .fil11 {fill:url(#id0)}
    .fil10 {fill:url(#id1)}
    .fil1 {fill:url(#id2)}
    .fil12 {fill:url(#id3)}
    .fil13 {fill:url(#id4)}
    .fil9 {fill:url(#id5)}
    .fil14 {fill:url(#id6)}
    .fil6 {fill:url(#id7)}
    .fil7 {fill:url(#id8)}
    .fil5 {fill:url(#id9)}
    .fil8 {fill:url(#id10)}
    .fil2 {fill:url(#id11)}
   ]]>
  </style>
  <linearGradient id="id0" y2="12552" gradientUnits="userSpaceOnUse" x2="13808" y1="12552" x1="11857">
   <stop stop-color="#EACD40" offset="0"/>
   <stop stop-color="#EFD635" offset=".43922"/>
   <stop stop-color="#F9E867" offset="1"/>
  </linearGradient>
  <linearGradient id="id1" y2="1579.8" gradientUnits="userSpaceOnUse" x2="12688" y1="2093" x1="9655.1">
   <stop stop-color="#F3E038" offset="0"/>
   <stop stop-color="#FCF4A3" offset=".47059"/>
   <stop stop-color="#FCF29A" offset="1"/>
  </linearGradient>
  <linearGradient id="id2" y2="1489.4" gradientUnits="userSpaceOnUse" x2="16741" y1="4309.8" x1="333.23">
   <stop stop-color="#FFCC29" offset="0"/>
   <stop stop-color="#FFFDAD" offset=".61176"/>
   <stop stop-color="#FFDD53" offset="1"/>
  </linearGradient>
  <linearGradient id="id3" y2="11744" gradientUnits="userSpaceOnUse" x2="6596.5" y1="12387" x1="6618.6">
   <stop stop-color="#F3E689" offset="0"/>
   <stop stop-color="#F7EA89" offset="1"/>
  </linearGradient>
  <linearGradient id="id4" y2="6225.7" gradientUnits="userSpaceOnUse" x2="10150" y1="5198.5" x1="7512.3">
   <stop stop-color="#F8E44F" offset="0"/>
   <stop stop-color="#F9EA72" offset=".43922"/>
   <stop stop-color="#FBF095" offset="1"/>
  </linearGradient>
  <linearGradient id="id5" y2="3804.8" gradientUnits="userSpaceOnUse" x2="13169" y1="4058" x1="14480">
   <stop stop-color="#F9E85B" offset="0"/>
   <stop stop-color="#ECD631" offset=".47059"/>
   <stop stop-color="#D2B42F" offset="1"/>
  </linearGradient>
  <linearGradient id="id6" y2="7748.1" xlink:href="#id0" gradientUnits="userSpaceOnUse" x2="2089.3" y1="7927.2" x1="1099">
  </linearGradient>
  <linearGradient id="id7" y2="6501.6" xlink:href="#id5" gradientUnits="userSpaceOnUse" x2="11623" y1="7722.2" x1="12208">
  </linearGradient>
  <linearGradient id="id8" y2="8990.8" xlink:href="#id5" gradientUnits="userSpaceOnUse" x2="14985" y1="10524" x1="15719">
  </linearGradient>
  <linearGradient id="id9" y2="8103.8" xlink:href="#id5" gradientUnits="userSpaceOnUse" x2="5339.9" y1="9054.5" x1="6799.6">
  </linearGradient>
  <linearGradient id="id10" y2="4273.1" gradientUnits="userSpaceOnUse" x2="3537.4" y1="4901.2" x1="5163">
   <stop stop-color="#F9E96B" offset="0"/>
   <stop stop-color="#F9E652" offset=".47059"/>
   <stop stop-color="#D2B42F" offset="1"/>
  </linearGradient>
  <radialGradient id="id11" cy="40%" cx="9%">
   <stop stop-color="#F9E95C" offset="0"/>
   <stop stop-color="#FBF5AA" offset=".25882"/>
   <stop stop-color="#FFF688" offset=".50196"/>
   <stop stop-color="#FDF552" offset=".69020"/>
   <stop stop-color="#FFCC29" offset="1"/>
  </radialGradient>
 </defs>
 <g id="Camada_x0020_1">
  <g id="_1071194208">
   <path class="fil0" d="m9010 1857c-2740 1067-5559 2022-8728 2491-208 38-282 218-282 477 187 2049 685 4001 1211 5945 518 940 4425 1462 5527 1659 1012 117 2024 234 3036 350 473-40 929-14 1362 102 2097 181 4176 185 6247 107 225-35 447-115 331-589-243-2566-425-5150-764-7687-294-762-587-1524-881-2287-96-175-210-331-384-428-335-259-699-492-584-1148-32-410-171-717-501-842-619-112-3641 928-5590 1849z"/>
   <path class="fil1" d="m393 4636c3711-551 7595-2089 10599-3505 1209-570 2495-801 3581-990 216 90 273 359 372 656-323 370 94 856 784 1382l954 2277c-2053 499-4204 835-6412 1075-764-367-1437-927-2870 126-2739-110-5098-459-7006-1022z"/>
   <path class="fil2" d="m16813 4782c258 2590 516 5180 774 7770 5 180-78 273-248 277-4801 270-11914-426-15262-1620-394-186-728-437-837-934l-1041-5352c-28-212 8-366 331-253 2210 621 4504 937 6870 988 572 721 1755 984 2890 15 2074-331 4148-662 6223-992 179-24 290-31 302 102z"/>
   <ellipse ry="415" rx="532" class="fil3" transform="matrix(1.2713 1.1973 -1.0478 1.2828 15458 9821.8)"/>
   <ellipse ry="415" rx="532" class="fil4" transform="matrix(.90018 -.16281 .35044 1.8335 1637.9 7978.7)"/>
   <path class="fil3" d="m5467 4396c-55 851-1705 962-1878 170-122-713 1500-749 1878-170z"/>
   <ellipse ry="415" rx="532" class="fil3" transform="matrix(1.2881 -.23151 .086090 1.3339 13922 3928.3)"/>
   <ellipse ry="415" rx="532" class="fil4" transform="matrix(1.7381 .36791 -.32329 1.641 6230.6 8691.4)"/>
   <path class="fil3" d="m9981 1895c586 951 2700 186 2233-895-516-280-2358 633-2233 895z"/>
   <path class="fil5" d="m6248 7903c511 108 864 501 790 877s-548 594-1059 486-864-501-790-877 548-594 1059-486z"/>
   <ellipse ry="415" rx="532" class="fil3" transform="matrix(1.0124 .95346 -.83436 1.0215 12014 7214.1)"/>
   <path class="fil6" d="m12292 6692c297 280 383 697 192 931s-588 197-885-83-383-697-192-931 588-197 885 83z"/>
   <path class="fil7" d="m15826 9231c373 352 481 875 241 1170-240 294-738 248-1111-104s-481-875-241-1170c240-294 738-248 1111 104z"/>
   <ellipse ry="415" rx="532" class="fil3" transform="matrix(.90018 -.16281 .35044 1.8335 1628.2 7930.1)"/>
   <path class="fil8" d="m5350 4396c-55 851-1705 962-1878 170-122-713 1500-749 1878-170z"/>
   <path class="fil9" d="m13821 3381c378-68 701 125 721 431s-271 609-649 677-701-125-721-431 271-609 649-677z"/>
   <path class="fil10" d="m9884 1948c586 951 2700 186 2233-895-516-280-2358 633-2233 895z"/>
   <path class="fil3" d="m6867 8246c192 171 292 394 249 612-74 376-548 594-1059 486-258-55-476-182-619-343 139 124 326 220 541 265 511 108 984-110 1059-486 37-186-31-377-171-534z"/>
   <path class="fil3" d="m11950 12913c742-902 1280-699 1951 122-662-131-1314-185-1951-122z"/>
   <path class="fil11" d="m11857 12942c742-902 1280-699 1951 122-662-131-1314-185-1951-122z"/>
   <path class="fil0" d="m5636 12084c9-11 1771 279 1942 298 4-10-3 5 0-6-258-675-1662-644-1942-292z"/>
   <path class="fil12" d="m5725 12100c-4 9 1611 255 1765 271 3-9-10-20-7-29-233-581-1505-544-1758-242z"/>
   <ellipse cy="5712" cx="8953" rx="1413" class="fil0" ry="706"/>
   <ellipse cy="5712" cx="8831" rx="1413" class="fil13" ry="705"/>
   <path class="fil14" d="m1449 7076c264-48 544 254 624 675s-69 800-333 848-544-254-624-675 69-800 333-848z"/>
  </g>
 </g>
</svg>
</a>
<p>The actual cheese represents were a C function pointer can go. Each hole represents a single class, a pocket universe, where only the C++ member function pointer can go. Where is the function pointer that can go <b>ANYWHERE</b>, like in C?</p>
<p>Ironically, this was not the case or less of an issue in the beginning of C++. Someone correct me if I am wrong. My knowledge of ancient C++ history is second hand. In the beginning of C++, C++ was a preprocessor, C with classes called CFront. The C++ cc files were converted from C++ into C. That would mean constructors, destructors, operators and member functions were converted to C functions which could be assigned to a C function pointer. This translation was never standardized either due to lack of interest or the desire to give compiler writers optimization opportunities. In either case, an important functionality went missing. So, Bjarne Stroustrup had it right all along.<!--Think too of the countless proposals over the decades of writers asking for a C ABI. Think too of recent history were the rush to add a new language feature to the language without providing translation to the existing C++ in the form of classes and the burfication that ensues along with the loss of useful features. Think too of all of the return based exception handling proposals which at the heart want something less implicit and magical and more explicitely defined in terms of existing constructs.--></p>
<p>"function_ref" tries to bridge this divide but falls short in some key areas. These become apparant by reviewing how function_ref is constructed and the limited test examples that guided its design and creation. "function_ref" <b>ONLY</b> has <b>ONE</b>, non copy, constructor which takes a const reference to a functor. The "erased_object/obj_" points to the functor and the "erased_function/callback_" to a binding function that calls the functor's call operator receiving not only the operator parameters but also the "erased_object/obj_".</p>
<!-- snippet-function_ref-constructor.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-constructor.cc}}
</div>
<p>It can be created by binding a functor, a C function pointer and a C++ member function pointer.</p>
<!-- snippet-function_ref-constructors.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-constructors.cc}}
</div>
<p>This gives the impression that it can bind to <i>anything</i> but it is only an illusion. There are important differences between these 3 use cases. Simply put, where is the type erasure? What is "erased_object/obj_" pointing to?</p>
<table class="inline_references">
<thead>
<tr>
<th>Signature</th>
<th>Binding</th>
<th>erased_object / obj_</th>
<th>Comments</th>
</tr>
</thead>
<tr>
<td>function_ref&lt;void(void)&gt;</td>
<td>[]{}</td>
<td>const reference to the functor</td>
<td>functors and stateful lambdas has first class support</td>
</tr>
<tr>
<td>function_ref&lt;void(void)&gt;</td>
<td>foo</td>
<td>There is no erased reference; erased_object/obj_ is unused.</td>
<td class="problem">While this case should be supported; void(void) binding to type erased void(void*) should also be supported.</td>
</tr>
<tr>
<td class="problem">function_ref&lt;void(bar)&gt;</td>
<td>&bar::baz</td>
<td class="problem">There is no erased reference.</td>
<td class="problem">NOTE: The signature changed. While the current case maybe should be supported where is the case where bar's this is type erased and the signature stays void(void).</td>
</tr>
</table>
<p>In other words, how do I do the following without virtual functions; cleanly.</p>
<!-- snippet-cpp-cleanly.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-cleanly.cc}}
</div>
<p>Interestingly a versus of C++, Borland now Embarcadero's C++ Builder, had this capability all along via their __closure language extension.</p>
<!-- snippet-__closure.cc.html -->
<div class="code">
{{> snippets/snippet-__closure.cc}}
</div>
<p>Similarly too, C# and all of the .NET languages had this via the single cast delegate.</p>
<!-- snippet-delegate.cc.html -->
<div class="code">
{{> snippets/snippet-delegate.cc}}
</div>
<p>This has also been the subject of two codeproject articles <a href="https://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible" target="__blank">"Member Function Pointers and the Fastest Possible C++ Delegates"</a> and <a href="https://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates" target="__blank">"The Impossibly Fast C++ Delegates"</a> from 2005 which focused on the runtime performance of solutions.</p>
<p>I am not the first to bring up the need for first class support of type erased C++ member function. Jonathan Mueller in his article <a href="https://www.foonathan.net/2017/01/function-ref-implementation/#a-word-about-member-function-pointers" target="__blank">Implementing function_view is harder than you might think</a> said the following:<br/>
<br/>
<i>The function_ref implementation presented here does not allow member function pointers, unlike std::function. The reason is simple: member function pointers are weird.<br/>
...<br/>
All that is just a lot of implementation hassle that is simply not worth it, especially with lambdas. If you want a member function, just use a lambda:<br/>
...<br/>
function_ref&lt;void(T&)&gt; ref([](T& obj){ obj.foo(); });</i><br/>
<br/>
This example like the example test case in the function_ref implementation just makes THIS into a parameter, changing the signature and not implementing the callback/__closure/delegate usecase. In order to use lambda expressions to bind to member functions, the THIS parameter must be captured as shown in the following example.</p>
<!-- snippet-cpp-lambda-capture.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-lambda-capture.cc}}
</div>
<p>Why not use lambda expressions with function_ref in order to <b>emulate</b> a callback?</p>
<ol>
    <li>erased_object/obj_ goes unused as the THIS pointer is stored in the functor/stateful lambda instead of in the function_ref</li>
    <li class="problem">DOUBLE INDIRECTION</li>
</ol>
<p>Concerning double direction, function_ref is a ref that points to a stateful lambda that contains a ref to the actual state. This is unsafe potential exhibiting lifetime errors and certainly makes it harder for the caller to reason about because the caller is responsible for keeping the state together with the lambda. Their is no need to impose this cognitive burden on all the users of function_ref when the implementation can be made once to handle it.</p>
<h2 id="fall_short">Where does function_ref fall short?</h2>
<p>The current function_ref specification and implementation has only one constructor that favors functors/lambdas with type erasure and does not provide comparable type erasure functionality to member function and free functions. The former is needed in order to handle the common callback usecase.</p>
<h2 id="alternate_realities">Solutions &amp; Alternate Realities</h2>
<p>The function_ref specification need to provide ways to construct function_ref(s); at least one for each use case.</p>
<ol>
    <li>functor/lambda</li>
    <li>function without type erasure</li>
    <li>member function without type erasure</li>
    <li>function with type erasure</li>
    <li>member function with type erasure</li>
</ol>
<p>While it would be ideal for all construction methodologies to be constructors, due to present limitations in the C++ language, some may need to be make functions.</p>
<h3>Construction Method #1: The Unsafe Constructor</h3>
<p>Reduce encapsulation some by providing a constructor to function_ref's internal pointers. This requires the function_ref specification to have a specific implementation.</p>
<!--<p>For function_ref&lt;int(int)&gt; there would be a two parameter constructor function_ref&lt;int(int)&gt;(void* obj_, int(*callback_)(int))</p>-->
<!-- snippet-cpp-unsafe-constructor.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-unsafe-constructor.cc}}
</div>
<p>This unsafe constructor, actually void* safe, is meant to be the foundation of the remaining and future construction methodologies.</p>
<!-- snippet-function_ref-prime.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-prime.cc}}
</div>
<!-- snippet-cpp-unsafe-constructor-usage-declarations.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-unsafe-constructor-usage-declarations.cc}}
</div>
<!-- snippet-cpp-unsafe-constructor-usage.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-unsafe-constructor-usage.cc}}
</div>
<h3>functor/lambda usecase</h3>
<p>The current implementation already handles this. Once the four other cases gets segregated out than the current solution may be able to be simplified.</p>
<!-- snippet-function_ref-prime.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-prime.cc}}
</div>
<!-- snippet-functor-lambda.cc.html -->
<div class="code">
{{> snippets/snippet-functor-lambda.cc}}
</div>
<!-- snippet-functor-lambda-usage.cc.html -->
<div class="code">
{{> snippets/snippet-functor-lambda-usage.cc}}
</div>
<h3>function without type erasure usecase</h3>
<p>The current implementation already handles this. Once the four other cases gets segregated out than the current solution may be able to be simplified.</p>
<!-- snippet-function_ref-prime.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-prime.cc}}
</div>
<!-- snippet-function-without-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-function-without-type-erasure.cc}}
</div>
<!-- snippet-function-without-type-erasure-usage.cc.html -->
<div class="code">
{{> snippets/snippet-function-without-type-erasure-usage.cc}}
</div>
<h3>function with type erasure usecase</h3>
<!-- snippet-function_ref-prime.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-prime.cc}}
</div>
<!-- snippet-function-with-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-function-with-type-erasure.cc}}
</div>
<!-- snippet-function-with-type-erasure-usage.cc.html -->
<div class="code">
{{> snippets/snippet-function-with-type-erasure-usage.cc}}
</div>
<h3>member function without type erasure usecase</h3>
<!-- snippet-function_ref-prime.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-prime.cc}}
</div>
<!-- snippet-member-function-without-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-member-function-without-type-erasure.cc}}
</div>
<!-- snippet-member-function-without-type-erasure-usage.cc.html -->
<div class="code">
{{> snippets/snippet-member-function-without-type-erasure-usage.cc}}
</div>
<h3>member function with type erasure usecase</h3>
<!-- snippet-function_ref-prime.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-prime.cc}}
</div>
<!-- snippet-member-function-with-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-member-function-with-type-erasure.cc}}
</div>
<!-- snippet-member-function-with-type-erasure-usage.cc.html -->
<div class="code">
{{> snippets/snippet-member-function-with-type-erasure-usage.cc}}
</div>
<h2 id="before_after">Before/After Comparisons</h2>
<b>Given</b>
<!-- snippet-function_ref-prime.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-prime.cc}}
</div>
<table style="width:100%">
<tr>
<td class="code" style="width:50%">
</td>
<td class="code" style="width:50%">
<!-- snippet-functor-lambda.cc.html -->
<div class="code">
{{> snippets/snippet-functor-lambda.cc}}
</div>
<!-- snippet-function-with-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-function-with-type-erasure.cc}}
</div>
<!-- snippet-function-without-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-function-without-type-erasure.cc}}
</div>
<!-- snippet-member-function-with-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-member-function-with-type-erasure.cc}}
</div>
<!-- snippet-member-function-without-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-member-function-without-type-erasure.cc}}
</div>
</td>
</tr>
</table>
<!-- snippet-cpp-unsafe-constructor-usage-declarations.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-unsafe-constructor-usage-declarations.cc}}
</div>
<hr/>
<table style="width:100%">
<tr>
<td style="width:50%;text-align:center">
<b>Before</b>
</td>
<td style="width:50%;text-align:center">
<b>After</b>
</td>
</tr>
</table>
<hr/>
<table style="width:100%">
<tr>
<td class="code" style="width:50%">
<!-- snippet-cpp-unsafe-constructor-usage.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-unsafe-constructor-usage.cc}}
</div>
</td>
<td class="code" style="width:50%">
<!-- snippet-cpp-unsafe-constructor-usage-alt.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-unsafe-constructor-usage-alt.cc}}
</div>
</td>
</tr>
</table>
<!--
[X] deduplication
[X] before/after
[] in between verbiage
[] rework examples
[] compiler support
	[] constructor template parameters
	[] casting function pointer with pointers to those with void pointers
	[] member function traits that convert functions into C variants
	[] alias to parameter packs and typelists
-->
<p>...</p>
<p>...</p>
<p>...</p>
<p>add typesafe versions of constructor even though a make function</p>
<p>little language support via a compiler function traits to provide minimal language support for the method type erasure</p>
<p>guaranteed inlining by allowing function pointers to be cast into other function points like what happens when using void pointer</p>
<p>major language upport as a language feature</p>
<h2 id="performance">Runtime Performance</h2>
<p>Things must first work than get optimized.</p>
<p>Brief mention of code project.</p>
<p>Contrast C implementation versus C++ implementation</p>
<p>...</p>
<p>...</p>
<p>...</p>
<s>
<h2 id="overview">Design Overview</h2>
<p><b>What are the advantages to allowing inspect to catch exceptions?</b><br/>
<ol>
<li>inspect won't widen the error handling bifurcation</li>
<li>inspect won't widen the error handling bifurcation in favor of the less standard return based over the more standard exception based</li>
<li>programmers can use a single mechanism to handle return based and exception based error handling at the statement level</li>
<li>other than for performance reasons, the need to create dual error handling API's is diminished because the consumer can handle it the same way</li>
</ol>
</p>
<p><b>NOTE:</b> If it makes it any easier to implement the desired functionality, the <i>init-statement<sub>opt</sub> condition</i> could be limited to a single function call, "inspect(a()) {", instead of a coumpound call such as "inspect(a() + e() - i() * o() / u()) {". This would be ok from a usability stand point because the programmer could always wrap the more complicated expression into a lamda.</p>
<p><b>Wouldn't we need some syntax to differentiate a type that could be both returned and thrown?</b><br/>NO. Exceptions typically are derived from the exception base class and are thrown not returned. Returns tend to be error_code or something else which is not derived from exception. Accounting for a rarely used same type in both context scenarios would greatly diminish the majority case as a whole. The whole point of this syntax is the developer in statement based error handling doesn't need to know how the function/expression in question produced the error. Further this fringe outlier can easily be resolved by the implementer of said function. It is much easier for a library writer to refrain from a fringe case than to resort to providing dual interfaces.</p>
<p>
<b>"How would we deal with the N+1 problem? Frequently new syntax is introduced as way to get rid of an older syntax, but frequently what happens is that we end up with the new syntax and the old syntax." (source unknown)</b><br/>
The current pattern matching proposal has already added new syntax which replaces in some circumstances if and switch. This proposal doesn't so much invent a new systax as it removes a perceived limitation or restriction. While some may think this revision puts inspect in competition with try/catch, I assure it doesn't. It is actually complementary. Try/Catch is block based. Return based error handling as well as pattern matching's inspect is statement based. Block based error handling is ideal when dealing with blocks. Statement based error handling is ideal when dealing with statements. Which one the programmer uses depends on the situation at the moment of need! A situation may have try/catch as a catch all for a whole function block. However in that same function, a specific function call is required to handle the error at the moment of the call due to business requirements of the error handling occurring before some other statement. At that moment, programmers reach for a statement based tool even though there is some catch handler catching everything else. I believe there is a misconception that for dual API's programmer's reach for eirther exception or return based API calls. However if your code base uses both than you are more likely to use both.
</p>
<h2 id="wording">Proposed Wording</h2>
<p>If the <i>init-statement<sub>opt</sub> condition</i> can throw an exception, then exceptions can be caught by inspect's <i>alternative-pattern</i>.</p>
</s>
<!--
<h2 id="design">Design Decisions</h2>
<p>TODO</p>
<h2 id="performance">Runtime Performance</h2>
<p>TODO</p>
<h2 id="examples">Examples</h2>
<p>TODO</p>
<h2 id="future">Future Work</h2>
<p>TODO</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>TODO</p>
-->
<h2 id="references">References</h2>
<span id="reference-p0792r0">[P0792R0] function_ref: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0792r0.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0792r0.html</a><br/>
<br/>
<span id="reference-p0792r1">[P0792R1] function_ref: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r1.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r1.html</a><br/>
<br/>
<span id="reference-p0792r2">[P0792R2] function_ref: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r2.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r2.html</a><br/>
<br/>
<span id="reference-p0792r3">[P0792R3] function_ref: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r3.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r3.html</a><br/>
<br/>
<span id="reference-p0792r4">[P0792R4] function_ref: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r4.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r4.html</a><br/>
<br/>
<span id="reference-p0792r5">[P0792R5] function_ref: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r5.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r5.html</a><br/>
<br/>
<span id="reference-cpp-pointer-declaration-function">cppreference.com ... Pointer declaration ... Pointers to functions</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://en.cppreference.com/w/cpp/language/pointer#Pointers_to_functions" target="__blank">https://en.cppreference.com/w/cpp/language/pointer#Pointers_to_functions</a><br/>
<br/>
<span id="reference-harder">Implementing function_view is harder than you might think</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://www.foonathan.net/2017/01/function-ref-implementation/" target="__blank">https://www.foonathan.net/2017/01/function-ref-implementation/</a><br/>
<br/>
<span id="reference-p1371r2">What is a “callback” in C and how are they implemented?</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://stackoverflow.com/questions/142789/what-is-a-callback-in-c-and-how-are-they-implemented" target="__blank">https://stackoverflow.com/questions/142789/what-is-a-callback-in-c-and-how-are-they-implemented</a><br/>
<br/>
<span id="reference-p1371r2">Using A C++ Object’s Member Function with C-style Callbacks</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://embeddedartistry.com/blog/2017/07/10/using-a-c-objects-member-function-with-c-style-callbacks/" target="__blank">https://embeddedartistry.com/blog/2017/07/10/using-a-c-objects-member-function-with-c-style-callbacks/</a><br/>
<br/>
<span id="reference-p1371r2">Callback (computer programming)</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://en.wikipedia.org/wiki/Callback_(computer_programming)" target="__blank">https://en.wikipedia.org/wiki/Callback_(computer_programming)</a><br/>
<br/>
<span id="reference-p1371r2">Function object</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://en.wikipedia.org/wiki/Function_object" target="__blank">https://en.wikipedia.org/wiki/Function_object</a><br/>
<br/>
<span id="reference-p1371r2">__closure</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://docwiki.embarcadero.com/RADStudio/Sydney/en/Closure" target="__blank">http://docwiki.embarcadero.com/RADStudio/Sydney/en/Closure</a><br/>
<br/>
<span id="reference-p1371r2">C++ Delegates and Borland's C++ Builder Event Handling - Part I</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://www.codeproject.com/Articles/44874/C-Delegates-and-Borland-s-C-Builder-Event-Handling" target="__blank">https://www.codeproject.com/Articles/44874/C-Delegates-and-Borland-s-C-Builder-Event-Handling</a><br/>
<br/>
<span id="reference-p1371r2">Delegates (C# Programming Guide)</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/" target="__blank">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/</a><br/>
<br/>
<span id="reference-p1371r2">Using Delegates (C# Programming Guide)</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/using-delegates" target="__blank">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/using-delegates</a><br/>
<br/>
<span id="reference-p1371r2">The Impossibly Fast C++ Delegates</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates" target="__blank">https://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates</a><br/>
<br/>
<span id="reference-p1371r2">Member Function Pointers and the Fastest Possible C++ Delegates</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible" target="__blank">https://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible</a><br/>
<br/>
<span id="reference-p1371r2">function_ref</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://github.com/TartanLlama/function_ref" target="__blank">https://github.com/TartanLlama/function_ref</a><br/>
<br/>
<span id="reference-p1371r2">On function_ref and string_view</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://quuxplusone.github.io/blog/2019/05/10/function-ref-vs-string-view/" target="__blank">https://quuxplusone.github.io/blog/2019/05/10/function-ref-vs-string-view/</a><br/>
<br/>
<span id="reference-p1371r2">How to pass and execute anonymous function as parameter in C++11?</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://newbedev.com/how-to-pass-and-execute-anonymous-function-as-parameter-in-c-11" target="__blank">https://newbedev.com/how-to-pass-and-execute-anonymous-function-as-parameter-in-c-11</a><br/>
<br/>
<span id="reference-p1371r2">Passing Functions to Functions in C++</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://tech.jocodoma.com/2019/02/27/Passing-Functions-to-Functions-in-CPP/" target="__blank">https://tech.jocodoma.com/2019/02/27/Passing-Functions-to-Functions-in-CPP/</a><br/>
<br/>
<span id="reference-p1371r2">passing functions to functions</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://vittorioromeo.info/index/blog/passing_functions_to_functions.html">https://vittorioromeo.info/index/blog/passing_functions_to_functions.html</a><br/>
<br/>
<span id="reference-p1371r2">function_view: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://vittorioromeo.info/Misc/fnview0.html" target="__blank">https://vittorioromeo.info/Misc/fnview0.html</a><br/>
<br/>
<span id="reference-p1371r2">Alternative to std::function for passing function as argument (callbacks, etc.)</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://stackoverflow.com/questions/39087141/alternative-to-stdfunction-for-passing-function-as-argument-callbacks-etc" target="__blank">https://stackoverflow.com/questions/39087141/alternative-to-stdfunction-for-passing-function-as-argument-callbacks-etc</a><br/>
<br/>
<span id="reference-p1371r2">Packs outside of Templates</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2277r0.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2277r0.html</a><br/>
<br/>
<span id="reference-p1371r2">A type trait to detect reference binding to temporary</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2255r0.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2255r0.html</a><br/>
<!--
function_ref
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0792r0.html
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r2.html
https://www.foonathan.net/2017/01/function-ref-implementation/
All that is just a lot of implementation hassle that is simply not worth it, especially with lambdas. If you want a member function, just use a lambda:

Prior Work
C function pointer and void pointer callback
https://stackoverflow.com/questions/142789/what-is-a-callback-in-c-and-how-are-they-implemented
void *userdata
...
struct event_cb {
    event_cb_t cb;
    void *data;
};
https://embeddedartistry.com/blog/2017/07/10/using-a-c-objects-member-function-with-c-style-callbacks/
converting member function into regular function
https://en.wikipedia.org/wiki/Callback_(computer_programming)
https://en.wikipedia.org/wiki/Function_object

Borland C++ Closure
http://docwiki.embarcadero.com/RADStudio/Sydney/en/Closure
https://www.codeproject.com/Articles/44874/C-Delegates-and-Borland-s-C-Builder-Event-Handling
// https://stackoverflow.com/questions/27769401/borland-style-closure-in-gcc

C# delegate
https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/
https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/using-delegates

Code Project
https://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates
https://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible

Other function_ref assessments
https://github.com/TartanLlama/function_ref
https://quuxplusone.github.io/blog/2019/05/10/function-ref-vs-string-view/
https://newbedev.com/how-to-pass-and-execute-anonymous-function-as-parameter-in-c-11
https://tech.jocodoma.com/2019/02/27/Passing-Functions-to-Functions-in-CPP/
https://vittorioromeo.info/index/blog/passing_functions_to_functions.html
https://stackoverflow.com/questions/39087141/alternative-to-stdfunction-for-passing-function-as-argument-callbacks-etc/39087660#39087660
https://vittorioromeo.info/Misc/fnview0.html
https://www.foonathan.net/2017/01/function-ref-implementation/
"just use a lambda"
The example provided does not type erase the this pointer.
https://stackoverflow.com/questions/39087141/alternative-to-stdfunction-for-passing-function-as-argument-callbacks-etc

CON
existing requires double indirection, another lifetime programmer has to manage

WHY
like C function pointer in C NOT C++ binds to anything VS. C++ swiss cheese

REQUESTS
language support
AND/OR
factories for common cases
AND/OR
implementation detail void constructor
AND/OR
implementation detail template T constructor
AND/OR
constructor template parameters
AND/OR
alias of type lists and parameter packs
-->
</body>
</html>
