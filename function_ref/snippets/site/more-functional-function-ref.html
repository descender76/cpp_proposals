<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>A More Functional function_ref</title>
  <meta name="description" content="A More Functional function_ref">
  <meta name="author" content="Jarrad Waterloo">
  <style>
    h1
	{
	  text-align : center;
	}
	.code
	{
	  background-color: AliceBlue;
	}
	table.inline_references
	{
		border: 1px solid black;
		border-collapse: collapse;
	}
	table.inline_references > thead > tr > th
	{
		border: 1px solid black;
	}
	table.inline_references > tbody > tr > td
	{
		border: 1px solid black;
	}
	.problem
	{
		font-weight : bold;
		color : red;
	}
	/*
	*/
  </style>
</head>
<body>
<h1>A More Functional function_ref</h1>
<table style="width:100%">
<tr>
<td>&nbsp;</td>
<td style="width:60ex">
  <table>
  <tr>
  <td><b>Document #:</b></td><td>PTODOR0</td>
  </tr>
  <tr>
  <td><b>Date:</b></td><td>2021-07-30</td>
  </tr>
  <tr>
  <td><b>Project:</b></td><td>Programming Language C++</td>
  </tr>
  <tr>
  <td><b>Audience:</b></td><td>Library Evolution Working Group (LEWG)</td>
  </tr>
  <tr>
  <td><b>Reply-to:</b></td><td>Jarrad J. Waterloo<br/>&lt;<a href="mailto:descender76@gmail.com">descender76@gmail.com</a>&gt;</td>
  </tr>
  </table>
</td>
</tr>
</table>
<h2>Contents</h2>
<h3><a href="#introduction">1&nbsp;&nbsp;Introduction</a></h3>
<h3><a href="#history_prior_work">2&nbsp;&nbsp;History &amp; Prior Work</a></h3>
<h3><a href="#fall_short">3&nbsp;&nbsp;Where does function_ref fall short?</a></h3>
<h3><a href="#alternate_realities">4&nbsp;&nbsp;Solutions &amp; Alternate Realities</a></h3>
<h3><a href="#before_after">5&nbsp;&nbsp;Before/After Comparisons</a></h3>
<h3><a href="#language_feature">6&nbsp;&nbsp;As a language/compiler feature</a></h3>
<h3><a href="#conclusion">7&nbsp;&nbsp;Conclusion</a></h3>
<h3><a href="#references">8&nbsp;&nbsp;References</a></h3>
<h3><a href="#ancillary-references">9&nbsp;&nbsp;Ancillary References</a></h3>
<h2 id="introduction">Introduction</h2>
<p>There are many types of runtime polymorphism each with their own PRO's and CON's. These range from single function callbacks to classes with multiple virtual member functions and even those with multiple type erased parameters. Even though C gives us callbacks via function pointers and C++ adds to our support of runtime polymorphism via its virtual functions, their is still considerable interest in other types of runtime polymorphism, as illustrated by just some of the proposals in past years.</p>
<table class="inline_references">
<thead>
<tr>
<th>Document Date</th>
<th>WG21 Number</th>
<th>Title</th>
<th>Author</th>
</tr>
</thead>
<tr>
<td>2017-02-06</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0288r1.pdf">P0288R1</a></td>
<td>A polymorphic wrapper for all Callable objects</td>
<td>David Krauss</td>
</tr>
<tr>
<td><i>2017-06-07</i></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0312r1.html"><i>P0312R1</i></a></td>
<td><i>Make Pointers to Members Callable</i></td>
<td><i>Barry Revzin</i></td>
</tr>
<tr>
<td>2017-10-16</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0201r2.pdf">P0201R2</a></td>
<td>A polymorphic value-type for C++</td>
<td>Jonathan Coe</td>
</tr>
<tr>
<td><b>2017-10-10</b></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0792r0.html"><b>P0792R0</b></a></td>
<td><b>function_ref: a non-owning reference to a Callable</b></td>
<td><b>Vittorio Romeo</b></td>
</tr>
<td>2018-02-12</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0201r3.pdf">P0201R3</a></td>
<td>A polymorphic value-type for C++</td>
<td>Jonathan Coe, Sean Parent</td>
</tr>
<tr>
<td><b>2017-11-26</b></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r1.html"><b>P0792R1</b></a></td>
<td><b>function_ref: a non-owning reference to a Callable</b></td>
<td><b>Vittorio Romeo</b></td>
</tr>
<tr>
<td>2018-02-12</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0957r0.pdf">P0957R0</a></td>
<td>PFA: A Generic, Extendable and Efficient Solution for Polymorphic Programming</td>
<td>Mingxin Wang</td>
</tr>
<tr>
<td><i>2018-04-01</i></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0984r0.pdf"><i>P0984R0</i></a></td>
<td><i>All (*)()-Pointers Replaced by Ideal Lambdas</i></td>
<td><i>Peter Sommerlad</i></td>
</tr>
<tr>
<td><b>2018-05-06</b></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r2.html"><b>P0792R2</b></a></td>
<td><b>function_ref: a non-owning reference to a Callable</b></td>
<td><b>Vittorio Romeo</b></td>
</tr>
<tr>
<td>2018-04-18</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0957r1.pdf">P0957R1</a></td>
<td>PFA: A Generic, Extendable and Efficient Solution for Polymorphic Programming</td>
<td>Mingxin Wang</td>
</tr>
<tr>
<td>2018-10-05</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0201r4.pdf">P0201R4</a></td>
<td>A polymorphic value-type for C++</td>
<td>Jonathan Coe, Sean Parent</td>
</tr>
<tr>
<td><b>2018-10-07</b></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r3.html"><b>P0792R3</b></a></td>
<td><b>function_ref: a non-owning reference to a Callable</b></td>
<td><b>Vittorio Romeo</b></td>
</tr>
<tr>
<td><i>2018-10-06</i></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1214r0.html"><i>P1214R0</i></a></td>
<td><i>Pointer to Member Functions and Member Objects are just Callables!</i></td>
<td><i>JeanHeyd Meneide</i></td>
</tr>
<td>2019-03-11</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0201r5.html">P0201R5</a></td>
<td>A polymorphic value-type for C++</td>
<td>Jonathan Coe, Sean Parent</td>
</tr>
<tr>
<td><b>2019-06-17</b></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r4.html"><b>P0792R4</b></a></td>
<td><b>function_ref: a non-owning reference to a Callable</b></td>
<td><b>Vittorio Romeo</b></td>
</tr>
<tr>
<td>2019-06-17</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0957r2.pdf">P0957R2</a></td>
<td>PFA: A Generic, Extendable and Efficient Solution for Polymorphic Programming</td>
<td>Mingxin Wang</td>
</tr>
<tr>
<td>2019-06-17</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1678r0.pdf">P1678R0</a></td>
<td>Callbacks and Composition</td>
<td>Kirk Shoop</td>
</tr>
<tr>
<td>2019-08-05</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1678r1.pdf"></a>P1678R1</td>
<td>Callbacks and Composition</td>
<td>Kirk Shoop</td>
</tr>
<tr>
<td>2019-10-07</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0288r5.html">P0288R5</a></td>
<td>any_invocable</td>
<td>Matt Calabrese, Ryan McDougall</td>
</tr>
<tr>
<td><b>2019-10-06</b></td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r5.html"><b>P0792R5</b></a></td>
<td><b>function_ref: a non-owning reference to a Callable</b></td>
<td><b>Vittorio Romeo</b></td>
</tr>
<tr>
<td>2019-10-07</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0957r3.pdf">P0957R3</a></td>
<td>PFA: A Generic, Extendable and Efficient Solution for Polymorphic Programming</td>
<td>Mingxin Wang</td>
</tr>
<tr>
<td>2019-10-06</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1678r2.pdf">P1678R2</a></td>
<td>Callbacks and Composition</td>
<td>Kirk Shoop</td>
</tr>
<tr>
<td>2019-11-23</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0957r4.pdf">P0957R4</a></td>
<td>PFA: A Generic, Extendable and Efficient Solution for Polymorphic Programming</td>
<td>Mingxin Wang</td>
</tr>
<tr>
<td>2020-03-04</td>
<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2123r0.html">P2123R0</a></td>
<td>interfaces: A Facility to Manage ABI/API Evolution</td>
<td>Hal Finkel, Tom Scogland</td>
</tr>
</table>
<p>One such is the single function callback as proposed in the <a href="#reference-p0792r5">function_ref</a> proposals. Upon closer examination, function_ref has some serious limitations and also does not handle a common use case. In order to better understand these limitations and the common use case, we need to examine callbacks historically and the prior work of others.</p>
<h2 id="history_prior_work">History &amp; Prior Work</h2>
<p><a href="#reference-p0792r5">function_ref</a> is most like <a href="#reference-cpp-pointer-declaration-function">C function pointers</a>. In the following example, int_return_int is the type of function pointer that points to a function that takes and returns an int. This example illustrates how a function pointer is declared, initiated and used.</p>
<!-- snippet-function-pointer-simple.cc.html -->
<div class="code">
{{> snippets/snippet-function-pointer-simple.cc}}
</div>
<p>While C function pointers are generally useful they can be temporarily limiting because the behavior of the provided function varies on the parameters passed by the caller of function pointer and not by the provider of the function. This limit is surpassed with a little bit of colaboration between the caller and the provider of the function by making a slight modification to the function pointer type signature that they agree to. Adding a void* to the parameter list of function pointer allows the provider of the to be called function to provide type erased state to influence the desired behavior of the function, provided of course the caller passes this state along.</p>
<!-- snippet-function-pointer-complex.cc.html -->
<div class="code">
{{> snippets/snippet-function-pointer-complex.cc}}
</div>
<p>Taking it a step forward the function pointer and the type erased user data can be combined since they are tightly related because they both come from the same provider.</p>
<!-- snippet-function-pointer-struct.cc.html -->
<div class="code">
{{> snippets/snippet-function-pointer-struct.cc}}
</div>
<p>Interesting this is comparable to how function_ref was <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r5.html#cb9-6" target="__blank">designed</a> and/or <a href="https://github.com/TartanLlama/function_ref/blob/master/include/tl/function_ref.hpp#L196" target="__blank">implemented</a>.</p>
<h3>Design</h3>
<p>Notice the type erased object. Notice also that the specification doesn't mention the type erased parameter passed to the "erased_function". (Just an oversight I guess.)</p>
<!-- snippet-function_ref-private-spec.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-private-spec.cc}}
</div>
<h3>Implementation</h3>
<p>Notice the type erased object and how it is passed to the function pointer.</p>
<!-- snippet-function_ref-private-impl.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-private-impl.cc}}
</div>
<p>So function_ref represents a subset of C function pointers where state specific to the implemented function may be passed along with it. "function_ref" makes working with these highly useful type erased callbacks safer because it ensures that the right state is bound to a compatible function and also that the caller actually passes along said state. "function_ref" is as essential to C++ as function pointers are to C in providing the ability to pass and return functions from functions for <a href="https://en.wikipedia.org/wiki/Functional_programming#First-class_and_higher-order_functions" target="__blank">functional programming<a>. "function_ref", once refined, is also important because it fixes a pseudo-mistake in C++ caused by bifurcation when adding new features to the language and in this case during the standardization process.</p>
<p><span class="problem">Function pointers are not the same in C as they are in C++</span>, even though C++ is somewhat a superset of C, at least in the case when it comes to support for C function pointers.</b>
<p>I am not talking about member function pointers, that is a whole other beast<!--subject-->. In C, int (*)(int) can point to <b>ANY</b> function that takes a int and returns an int. That is both easy and very useful. In C++, a "C" function pointer can not point to a constructor, a destructor, an operator or a member function without having to create binders i.e. translation functions. By adding constructors, destructors, operators and member functions to the language a manifold bifurcation ensued especially since there was no implicit or explicit conversions of the new language constructs to the prior language feature of function pointers. What was once easy is now tedious! C function pointers in C++ is like swiss cheese.</p>
<a href="https://freesvg.org/swiss-cheese" target="__blank">
<svg style="shape-rendering:geometricPrecision;text-rendering:geometricPrecision;image-rendering:optimizeQuality" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" xml:space="preserve" height="130.64mm" width="177.46mm" version="1.1" clip-rule="evenodd" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 17746 13064">
 <defs>
  <style type="text/css">
   <![CDATA[
    .fil3 {fill:#FEFEFE}
    .fil4 {fill:#FFF688}
    .fil0 {fill:#FCF4A7}
    .fil11 {fill:url(#id0)}
    .fil10 {fill:url(#id1)}
    .fil1 {fill:url(#id2)}
    .fil12 {fill:url(#id3)}
    .fil13 {fill:url(#id4)}
    .fil9 {fill:url(#id5)}
    .fil14 {fill:url(#id6)}
    .fil6 {fill:url(#id7)}
    .fil7 {fill:url(#id8)}
    .fil5 {fill:url(#id9)}
    .fil8 {fill:url(#id10)}
    .fil2 {fill:url(#id11)}
   ]]>
  </style>
  <linearGradient id="id0" y2="12552" gradientUnits="userSpaceOnUse" x2="13808" y1="12552" x1="11857">
   <stop stop-color="#EACD40" offset="0"/>
   <stop stop-color="#EFD635" offset=".43922"/>
   <stop stop-color="#F9E867" offset="1"/>
  </linearGradient>
  <linearGradient id="id1" y2="1579.8" gradientUnits="userSpaceOnUse" x2="12688" y1="2093" x1="9655.1">
   <stop stop-color="#F3E038" offset="0"/>
   <stop stop-color="#FCF4A3" offset=".47059"/>
   <stop stop-color="#FCF29A" offset="1"/>
  </linearGradient>
  <linearGradient id="id2" y2="1489.4" gradientUnits="userSpaceOnUse" x2="16741" y1="4309.8" x1="333.23">
   <stop stop-color="#FFCC29" offset="0"/>
   <stop stop-color="#FFFDAD" offset=".61176"/>
   <stop stop-color="#FFDD53" offset="1"/>
  </linearGradient>
  <linearGradient id="id3" y2="11744" gradientUnits="userSpaceOnUse" x2="6596.5" y1="12387" x1="6618.6">
   <stop stop-color="#F3E689" offset="0"/>
   <stop stop-color="#F7EA89" offset="1"/>
  </linearGradient>
  <linearGradient id="id4" y2="6225.7" gradientUnits="userSpaceOnUse" x2="10150" y1="5198.5" x1="7512.3">
   <stop stop-color="#F8E44F" offset="0"/>
   <stop stop-color="#F9EA72" offset=".43922"/>
   <stop stop-color="#FBF095" offset="1"/>
  </linearGradient>
  <linearGradient id="id5" y2="3804.8" gradientUnits="userSpaceOnUse" x2="13169" y1="4058" x1="14480">
   <stop stop-color="#F9E85B" offset="0"/>
   <stop stop-color="#ECD631" offset=".47059"/>
   <stop stop-color="#D2B42F" offset="1"/>
  </linearGradient>
  <linearGradient id="id6" y2="7748.1" xlink:href="#id0" gradientUnits="userSpaceOnUse" x2="2089.3" y1="7927.2" x1="1099">
  </linearGradient>
  <linearGradient id="id7" y2="6501.6" xlink:href="#id5" gradientUnits="userSpaceOnUse" x2="11623" y1="7722.2" x1="12208">
  </linearGradient>
  <linearGradient id="id8" y2="8990.8" xlink:href="#id5" gradientUnits="userSpaceOnUse" x2="14985" y1="10524" x1="15719">
  </linearGradient>
  <linearGradient id="id9" y2="8103.8" xlink:href="#id5" gradientUnits="userSpaceOnUse" x2="5339.9" y1="9054.5" x1="6799.6">
  </linearGradient>
  <linearGradient id="id10" y2="4273.1" gradientUnits="userSpaceOnUse" x2="3537.4" y1="4901.2" x1="5163">
   <stop stop-color="#F9E96B" offset="0"/>
   <stop stop-color="#F9E652" offset=".47059"/>
   <stop stop-color="#D2B42F" offset="1"/>
  </linearGradient>
  <radialGradient id="id11" cy="40%" cx="9%">
   <stop stop-color="#F9E95C" offset="0"/>
   <stop stop-color="#FBF5AA" offset=".25882"/>
   <stop stop-color="#FFF688" offset=".50196"/>
   <stop stop-color="#FDF552" offset=".69020"/>
   <stop stop-color="#FFCC29" offset="1"/>
  </radialGradient>
 </defs>
 <g id="Camada_x0020_1">
  <g id="_1071194208">
   <path class="fil0" d="m9010 1857c-2740 1067-5559 2022-8728 2491-208 38-282 218-282 477 187 2049 685 4001 1211 5945 518 940 4425 1462 5527 1659 1012 117 2024 234 3036 350 473-40 929-14 1362 102 2097 181 4176 185 6247 107 225-35 447-115 331-589-243-2566-425-5150-764-7687-294-762-587-1524-881-2287-96-175-210-331-384-428-335-259-699-492-584-1148-32-410-171-717-501-842-619-112-3641 928-5590 1849z"/>
   <path class="fil1" d="m393 4636c3711-551 7595-2089 10599-3505 1209-570 2495-801 3581-990 216 90 273 359 372 656-323 370 94 856 784 1382l954 2277c-2053 499-4204 835-6412 1075-764-367-1437-927-2870 126-2739-110-5098-459-7006-1022z"/>
   <path class="fil2" d="m16813 4782c258 2590 516 5180 774 7770 5 180-78 273-248 277-4801 270-11914-426-15262-1620-394-186-728-437-837-934l-1041-5352c-28-212 8-366 331-253 2210 621 4504 937 6870 988 572 721 1755 984 2890 15 2074-331 4148-662 6223-992 179-24 290-31 302 102z"/>
   <ellipse ry="415" rx="532" class="fil3" transform="matrix(1.2713 1.1973 -1.0478 1.2828 15458 9821.8)"/>
   <ellipse ry="415" rx="532" class="fil4" transform="matrix(.90018 -.16281 .35044 1.8335 1637.9 7978.7)"/>
   <path class="fil3" d="m5467 4396c-55 851-1705 962-1878 170-122-713 1500-749 1878-170z"/>
   <ellipse ry="415" rx="532" class="fil3" transform="matrix(1.2881 -.23151 .086090 1.3339 13922 3928.3)"/>
   <ellipse ry="415" rx="532" class="fil4" transform="matrix(1.7381 .36791 -.32329 1.641 6230.6 8691.4)"/>
   <path class="fil3" d="m9981 1895c586 951 2700 186 2233-895-516-280-2358 633-2233 895z"/>
   <path class="fil5" d="m6248 7903c511 108 864 501 790 877s-548 594-1059 486-864-501-790-877 548-594 1059-486z"/>
   <ellipse ry="415" rx="532" class="fil3" transform="matrix(1.0124 .95346 -.83436 1.0215 12014 7214.1)"/>
   <path class="fil6" d="m12292 6692c297 280 383 697 192 931s-588 197-885-83-383-697-192-931 588-197 885 83z"/>
   <path class="fil7" d="m15826 9231c373 352 481 875 241 1170-240 294-738 248-1111-104s-481-875-241-1170c240-294 738-248 1111 104z"/>
   <ellipse ry="415" rx="532" class="fil3" transform="matrix(.90018 -.16281 .35044 1.8335 1628.2 7930.1)"/>
   <path class="fil8" d="m5350 4396c-55 851-1705 962-1878 170-122-713 1500-749 1878-170z"/>
   <path class="fil9" d="m13821 3381c378-68 701 125 721 431s-271 609-649 677-701-125-721-431 271-609 649-677z"/>
   <path class="fil10" d="m9884 1948c586 951 2700 186 2233-895-516-280-2358 633-2233 895z"/>
   <path class="fil3" d="m6867 8246c192 171 292 394 249 612-74 376-548 594-1059 486-258-55-476-182-619-343 139 124 326 220 541 265 511 108 984-110 1059-486 37-186-31-377-171-534z"/>
   <path class="fil3" d="m11950 12913c742-902 1280-699 1951 122-662-131-1314-185-1951-122z"/>
   <path class="fil11" d="m11857 12942c742-902 1280-699 1951 122-662-131-1314-185-1951-122z"/>
   <path class="fil0" d="m5636 12084c9-11 1771 279 1942 298 4-10-3 5 0-6-258-675-1662-644-1942-292z"/>
   <path class="fil12" d="m5725 12100c-4 9 1611 255 1765 271 3-9-10-20-7-29-233-581-1505-544-1758-242z"/>
   <ellipse cy="5712" cx="8953" rx="1413" class="fil0" ry="706"/>
   <ellipse cy="5712" cx="8831" rx="1413" class="fil13" ry="705"/>
   <path class="fil14" d="m1449 7076c264-48 544 254 624 675s-69 800-333 848-544-254-624-675 69-800 333-848z"/>
  </g>
 </g>
</svg>
</a>
<p>The actual cheese represents were a C function pointer can go. Each hole represents a single class, a pocket universe, where only the C++ member function pointer can go. Where is the function pointer that can go <b>ANYWHERE</b>, like in C?</p>
<p>Ironically, this was not the case or less of an issue in the beginning of C++. Someone correct me if I am wrong. My knowledge of ancient C++ history is second hand. In the beginning of C++, C++ was a preprocessor, C with classes called CFront. The C++ cc files were converted from C++ into C. That would mean constructors, destructors, operators and member functions were converted to C functions which could be assigned to a C function pointer. This translation was never standardized either due to lack of interest or the desire to give compiler writers optimization opportunities. In either case, an important functionality went missing. So, Bjarne Stroustrup had it right all along.<!--Think too of the countless proposals over the decades of writers asking for a C ABI. Think too of recent history were the rush to add a new language feature to the language without providing translation to the existing C++ in the form of classes and the burfication that ensues along with the loss of useful features. Think too of all of the return based exception handling proposals which at the heart want something less implicit and magical and more explicitely defined in terms of existing constructs.--></p>
<p>"function_ref" tries to bridge this divide but falls short in some key areas. These become apparant by reviewing how function_ref is constructed and the limited test examples that guided its design and creation. "function_ref" <b>ONLY</b> has <b>ONE</b>, non copy, constructor which takes a const reference to a functor. The "erased_object/obj_" points to the functor and the "erased_function/callback_" to a binding function that calls the functor's call operator receiving not only the operator parameters but also the "erased_object/obj_".</p>
<!-- snippet-function_ref-constructor.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-constructor.cc}}
</div>
<p>It can be created by binding a functor, a C function pointer and a C++ member function pointer.</p>
<!-- snippet-function_ref-constructors.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-constructors.cc}}
</div>
<p>This gives the impression that it can bind to <i>anything</i> but it is only an illusion. There are important differences between these 3 use cases. Simply put, where is the type erasure? What is "erased_object/obj_" pointing to?</p>
<table class="inline_references">
<thead>
<tr>
<th>Signature</th>
<th>Binding</th>
<th>erased_object / obj_</th>
<th>Comments</th>
</tr>
</thead>
<tr>
<td>function_ref&lt;void(void)&gt;</td>
<td>[]{}</td>
<td>const reference to the functor</td>
<td>functors and stateful lambdas has first class support</td>
</tr>
<tr>
<td>function_ref&lt;void(void)&gt;</td>
<td>foo</td>
<td>There is no erased reference; erased_object/obj_ is unused.</td>
<td class="problem">While this case should be supported; void(void) binding to type erased void(void*) should also be supported.</td>
</tr>
<tr>
<td class="problem">function_ref&lt;void(bar)&gt;</td>
<td>&bar::baz</td>
<td class="problem">There is no erased reference.</td>
<td class="problem">NOTE: The signature changed. While the current case maybe should be supported where is the case where bar's this is type erased and the signature stays void(void).</td>
</tr>
</table>
<p>In other words, how do I do the following without virtual functions; cleanly.</p>
<!-- snippet-cpp-cleanly.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-cleanly.cc}}
</div>
<p>Interestingly a versus of C++, Borland now Embarcadero's C++ Builder, had this capability all along via their __closure language extension.</p>
<!-- snippet-__closure.cc.html -->
<div class="code">
{{> snippets/snippet-__closure.cc}}
</div>
<p>Similarly too, C# and all of the .NET languages had this via the single cast delegate.</p>
<!-- snippet-delegate.cc.html -->
<div class="code">
{{> snippets/snippet-delegate.cc}}
</div>
<p>This has also been the subject of two codeproject articles <a href="https://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible" target="__blank">"Member Function Pointers and the Fastest Possible C++ Delegates"</a> and <a href="https://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates" target="__blank">"The Impossibly Fast C++ Delegates"</a> from 2005 which focused on the runtime performance of solutions.</p>
<p>I am not the first to bring up the need for first class support of type erased C++ member function. Jonathan Mueller in his article <a href="https://www.foonathan.net/2017/01/function-ref-implementation/#a-word-about-member-function-pointers" target="__blank">Implementing function_view is harder than you might think</a> said the following:<br/>
<br/>
<i>The function_ref implementation presented here does not allow member function pointers, unlike std::function. The reason is simple: member function pointers are weird.<br/>
...<br/>
All that is just a lot of implementation hassle that is simply not worth it, especially with lambdas. If you want a member function, just use a lambda:<br/>
...<br/>
function_ref&lt;void(T&)&gt; ref([](T& obj){ obj.foo(); });</i><br/>
<br/>
This example like the example test case in the function_ref implementation just makes THIS into a parameter, changing the signature and not implementing the callback/__closure/delegate usecase. In order to use lambda expressions to bind to member functions, the THIS parameter must be captured as shown in the following example.</p>
<!-- snippet-cpp-lambda-capture.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-lambda-capture.cc}}
</div>
<p>Why not use lambda expressions with function_ref in order to <b>emulate</b> a callback?</p>
<ol>
    <li>erased_object/obj_ goes unused as the THIS pointer is stored in the functor/stateful lambda instead of in the function_ref</li>
    <li class="problem">DOUBLE INDIRECTION</li>
</ol>
<p>Concerning double direction, function_ref is a ref that points to a stateful lambda that contains a ref to the actual state. This is unsafe potential exhibiting lifetime errors and certainly makes it harder for the caller to reason about because the caller is responsible for keeping the state together with the lambda. Their is no need to impose this cognitive burden on all the users of function_ref when the implementation can be made once to handle it.</p>
<h2 id="fall_short">Where does function_ref fall short?</h2>
<p>The current function_ref specification and implementation has only one constructor that favors functors/lambdas with type erasure and does not provide comparable type erasure functionality to member function and free functions. The former is needed in order to handle the common callback usecase.</p>
<h2 id="alternate_realities">Solutions &amp; Alternate Realities</h2>
<p>The function_ref specification need to provide ways to construct function_ref(s); at least one for each use case.</p>
<ol>
    <li>functor/lambda</li>
    <li>function without type erasure</li>
    <li>member function without type erasure</li>
    <li>function with type erasure</li>
    <li>member function with type erasure</li>
</ol>
<p>While it would be ideal for all construction methodologies to be constructors, due to present limitations in the C++ language, some may need to be make functions.</p>
<h3>Construction Method #1: The Unsafe Constructor</h3>
<p>Reduce encapsulation some by providing a constructor to function_ref's internal pointers. This requires the function_ref specification to have a specific implementation.</p>
<!--<p>For function_ref&lt;int(int)&gt; there would be a two parameter constructor function_ref&lt;int(int)&gt;(void* obj_, int(*callback_)(int))</p>-->
<!-- snippet-cpp-unsafe-constructor.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-unsafe-constructor.cc}}
</div>
<p>This unsafe constructor, actually void* safe, is meant to be the foundation of the remaining and future construction methodologies.</p>
<!-- snippet-function_ref-prime.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-prime.cc}}
</div>
<!-- snippet-cpp-unsafe-constructor-usage-declarations.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-unsafe-constructor-usage-declarations.cc}}
</div>
<!-- snippet-cpp-unsafe-constructor-usage.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-unsafe-constructor-usage.cc}}
</div>
<h3>functor/lambda usecase</h3>
<p>The current implementation already handles this. Once the four other cases gets segregated out than the current solution may be able to be simplified.</p>
<!-- snippet-function_ref-prime.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-prime.cc}}
</div>
<!-- snippet-functor-lambda.cc.html -->
<div class="code">
{{> snippets/snippet-functor-lambda.cc}}
</div>
<!-- snippet-functor-lambda-usage.cc.html -->
<div class="code">
{{> snippets/snippet-functor-lambda-usage.cc}}
</div>
<h3>function without type erasure usecase</h3>
<p>The current implementation already handles this. Once the four other cases gets segregated out than the current solution may be able to be simplified.</p>
<!-- snippet-function_ref-prime.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-prime.cc}}
</div>
<!-- snippet-function-without-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-function-without-type-erasure.cc}}
</div>
<!-- snippet-function-without-type-erasure-usage.cc.html -->
<div class="code">
{{> snippets/snippet-function-without-type-erasure-usage.cc}}
</div>
<h3>function with type erasure usecase</h3>
<!-- snippet-function_ref-prime.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-prime.cc}}
</div>
<!-- snippet-function-with-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-function-with-type-erasure.cc}}
</div>
<!-- snippet-function-with-type-erasure-usage.cc.html -->
<div class="code">
{{> snippets/snippet-function-with-type-erasure-usage.cc}}
</div>
<h3>member function without type erasure usecase</h3>
<!-- snippet-function_ref-prime.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-prime.cc}}
</div>
<!-- snippet-member-function-without-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-member-function-without-type-erasure.cc}}
</div>
<!-- snippet-member-function-without-type-erasure-usage.cc.html -->
<div class="code">
{{> snippets/snippet-member-function-without-type-erasure-usage.cc}}
</div>
<h3>member function with type erasure usecase</h3>
<!-- snippet-function_ref-prime.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-prime.cc}}
</div>
<!-- snippet-member-function-with-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-member-function-with-type-erasure.cc}}
</div>
<!-- snippet-member-function-with-type-erasure-usage.cc.html -->
<div class="code">
{{> snippets/snippet-member-function-with-type-erasure-usage.cc}}
</div>
<h2 id="before_after">Before/After Comparisons</h2>
<b>Given</b>
<!-- snippet-function_ref-prime.cc.html -->
<div class="code">
{{> snippets/snippet-function_ref-prime.cc}}
</div>
<table style="width:100%">
<tr>
<td class="code" style="width:50%">
</td>
<td class="code" style="width:50%">
<!-- snippet-functor-lambda.cc.html -->
<div class="code">
{{> snippets/snippet-functor-lambda.cc}}
</div>
<!-- snippet-function-with-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-function-with-type-erasure.cc}}
</div>
<!-- snippet-function-without-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-function-without-type-erasure.cc}}
</div>
<!-- snippet-member-function-with-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-member-function-with-type-erasure.cc}}
</div>
<!-- snippet-member-function-without-type-erasure.cc.html -->
<div class="code">
{{> snippets/snippet-member-function-without-type-erasure.cc}}
</div>
</td>
</tr>
</table>
<!-- snippet-cpp-unsafe-constructor-usage-declarations.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-unsafe-constructor-usage-declarations.cc}}
</div>
<hr/>
<table style="width:100%">
<tr>
<td style="width:50%;text-align:center">
<b>Before</b>
</td>
<td style="width:50%;text-align:center">
<b>After</b>
</td>
</tr>
</table>
<hr/>
<table style="width:100%">
<tr>
<td class="code" style="width:50%">
<!-- snippet-cpp-unsafe-constructor-usage.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-unsafe-constructor-usage.cc}}
</div>
</td>
<td class="code" style="width:50%">
<!-- snippet-cpp-unsafe-constructor-usage-alt.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-unsafe-constructor-usage-alt.cc}}
</div>
</td>
</tr>
</table>
<h2 id="language_feature">As a language/compiler feature</h2>
<h3>Just let the language/compiler do it all.</h3>
<p>The is certainly some appeal for the language/compiler to handle everything because it could handle all of the functional bifurcation that has accrued over the decades including the recent noexcept. However, there is also some appeal to a library based solution because it would allow the language to remain simpler with fewer keywords and ultimately easier to master. This is similar in principle to metaclasses and the reflection proposals which would similarly allow us to do more in libraries instead of as language features. At the end of the day, a consumer doesn't care as long as they can easily perform callbacks.</p>
<h3>constructor template parameters</h3>
<p>Currently, function_ref with enhancements for all 5 use cases needs at least five unique sets of function parameters. There is the single parameter to a functor. There is the single template parameter to a function. There is the single template parameter to a member function. There are two parameters, one template parameter to a function and one regular type erased pointer. There are two parameters, one template parameter to a member function and one regular type erased pointer. These 5 are mutually exclusive and overloadable. Using constructors are more desirable than using static make functions especially when these functions currently can't be written as a single template free function but requires a class and up to 2 static methods. If constructors could take a template parameter list like any other function does than we would be a step closer to making constructors instead of make functions a reality.</p>
<h3>[member] function traits</h3>
The implementation of function_ref is complicated mostly by all the binders to a type erased function pointer that must be created. If we had compiler generated function traits and member function traits than constructor template parameters would not be needed on the function_ref class at all. The 2013/08/05 article <a href="https://functionalcpp.wordpress.com/2013/08/05/function-traits/" target="__blank">Function Traits</a> demonstrates the need of function traits but it doesn't go far enough for function_ref uses. First of all there are no params alias to the parameter pack nor a parameter types alias to the same. This can't be performed currently in C++ because we can't have alias to parameter packs or type lists in C++. Some of the current C++ type traits require compiler based implementations. Similarly, if the compiler provided the following functions pointers than function_ref would become trivial.<br/>
<br/>
function_trait&lt;function&gt;::type_erase_first<br/>
function_trait&lt;function&gt;::add_void_pointer<br/>
member_function_trait&lt;function&gt;::type_erase_this or function_trait&lt;member_function&gt;::type_erase_this<br/>
member_function_trait&lt;function&gt;::ref or function_trait&lt;member_function&gt;::ref<br/>
member_function_trait&lt;function&gt;::cref or function_trait&lt;member_function&gt;::cref<br/>
member_function_trait&lt;function&gt;::pointer or function_trait&lt;member_function&gt;::pointer<br/>
member_function_trait&lt;function&gt;::cpointer or function_trait&lt;member_function&gt;::cpointer<br/>
member_function_trait&lt;function&gt;::value or function_trait&lt;member_function&gt;::value<br/>
member_function_trait&lt;function&gt;::cvalue or function_trait&lt;member_function&gt;::cvalue<br/>
<br/>
Also note that the compiler providing at least one of the following subset of the above would mean we would have regained what was lost when CFront became the first C++ standard.<br/>
<br/>
member_function_trait&lt;function&gt;::ref or function_trait&lt;member_function&gt;::ref<br/>
member_function_trait&lt;function&gt;::cref or function_trait&lt;member_function&gt;::cref<br/>
member_function_trait&lt;function&gt;::pointer or function_trait&lt;member_function&gt;::pointer<br/>
member_function_trait&lt;function&gt;::cpointer or function_trait&lt;member_function&gt;::cpointer<br/>
member_function_trait&lt;function&gt;::value or function_trait&lt;member_function&gt;::value<br/>
member_function_trait&lt;function&gt;::cvalue or function_trait&lt;member_function&gt;::cvalue<br/>
<h3>alias to parameter packs and typelists</h3>
<p>Function traits and member function traits could be completely created as a library provided we had just the typelist and parameter pack aliasing feature of the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1858r2.html" target="__blank">Generalized pack declaration and usage</a> proposal.</p>
<h3>void* composition i.e. guaranteed inlining i.e. advance casting</h3>
<p>Add some advanced casting to the standard C++ casting. In particular, allow non member function pointers to be explicitly cast to other non member function pointers provided all types and return type of said function pointer are the same and in the exact order except that pointers can be replaced with void pointers.</p>
<p>Example: allow double(*)(int*, bool, int, float, double) to be cast to double(*)(void*, bool, int, float, double) and the pointer to still callable provided the caller ensures that a void* that points to int is passed to the function pointer.</p>
<p>This is just an extension of what void pointers can currently do. First by composing void pointers; which this function_ref proposal doesn't need but may be still valuable to other type erasure libraries. Secondly, by applying these void pointer composition to function pointers which this function_ref proposal could benefit from. Ironically this works even now in C++ using a little bit of undefined behavior as the following example shows. In this example, the C++ ability for non member function pointers to be cast explicitly to a void pointer is used. This void pointer is immediately cast to a function pointer with type erased parameters. While logical, the undefined behavior is that the new functional pointer is still callable.</p>
<!-- snippet-cpp-function-pointer-cast.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-function-pointer-cast.cc}}
</div>
<p>This feature could be combined with constructor template parameters to provide a simple and typesafe constructor.</p>
<!-- snippet-cpp-safe-constructor.cc.html -->
<div class="code">
{{> snippets/snippet-cpp-safe-constructor.cc}}
</div>
<p>This void* composition and advance casting would provide a guaranteed inlining and would turn one undefined behavior into a defined behavior.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The deficiency of the current function_ref proposal is summed up in its title, "function_ref: a non-owning reference to a Callable". A callable [object] shows ts preferential treatment for functors/stateful lambdas over member functions and at times even regular functions with how it handles type erasure. Fortunately, the state of the existing implementation is well designed and is capable of handling more use cases than what its public interface and specification allows. At a minimum, a refined function_ref only needs nailing down its implentation to a void pointer a free function pointer along with exposing these two via a public constructor. Allowing these minimal changes would open up the provider of function_ref(s) to handle type erased member function use cases akin to delegates in .NET without any unacceptable double indirections. With supporting optional make functions, the propagation of the parameters can be performed explicitly and safely. Further this proposal outlines some minor language enhancements for future proposals given any interest that could make constructors of templates more consistent with other functions and update type erasure with logic extensions that could also remove one undefined behavior by making it logically defined.</p>
<h2 id="references">References</h2>
<span id="reference-p0792r0">[P0792R0] function_ref: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0792r0.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0792r0.html</a><br/>
<br/>
<span id="reference-p0792r1">[P0792R1] function_ref: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r1.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r1.html</a><br/>
<br/>
<span id="reference-p0792r2">[P0792R2] function_ref: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r2.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r2.html</a><br/>
<br/>
<span id="reference-p0792r3">[P0792R3] function_ref: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r3.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0792r3.html</a><br/>
<br/>
<span id="reference-p0792r4">[P0792R4] function_ref: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r4.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r4.html</a><br/>
<br/>
<span id="reference-p0792r5">[P0792R5] function_ref: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r5.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r5.html</a><br/>
<br/>
<span id="reference-cpp-pointer-declaration-function">cppreference.com ... Pointer declaration ... Pointers to functions</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://en.cppreference.com/w/cpp/language/pointer#Pointers_to_functions" target="__blank">https://en.cppreference.com/w/cpp/language/pointer#Pointers_to_functions</a><br/>
<br/>
<span id="reference-p1371r2">function_ref</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://github.com/TartanLlama/function_ref" target="__blank">https://github.com/TartanLlama/function_ref</a><br/>
<br/>
<span id="reference-p1371r2">Functional programming</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://en.wikipedia.org/wiki/Functional_programming#First-class_and_higher-order_functions" target="__blank">https://en.wikipedia.org/wiki/Functional_programming#First-class_and_higher-order_functions</a><br/>
<br/>
<span id="reference-p1371r2">Swiss cheese</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://freesvg.org/swiss-cheese" target="__blank">https://freesvg.org/swiss-cheese</a><br/>
<br/>
<span id="reference-p1371r2">__closure</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://docwiki.embarcadero.com/RADStudio/Sydney/en/Closure" target="__blank">http://docwiki.embarcadero.com/RADStudio/Sydney/en/Closure</a><br/>
<br/>
<span id="reference-p1371r2">Using Delegates (C# Programming Guide)</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/using-delegates" target="__blank">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/using-delegates</a><br/>
<br/>
<span id="reference-p1371r2">Member Function Pointers and the Fastest Possible C++ Delegates</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible" target="__blank">https://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible</a><br/>
<br/>
<span id="reference-p1371r2">The Impossibly Fast C++ Delegates</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates" target="__blank">https://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates</a><br/>
<br/>
<span id="reference-harder">Implementing function_view is harder than you might think</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://www.foonathan.net/2017/01/function-ref-implementation/" target="__blank">https://www.foonathan.net/2017/01/function-ref-implementation/</a><br/>
<br/>
<span id="reference-p1371r2">Function Traits</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://functionalcpp.wordpress.com/2013/08/05/function-traits/" target="__blank">https://functionalcpp.wordpress.com/2013/08/05/function-traits/</a><br/>
<br/>
<span id="reference-p1858r2">Generalized pack declaration and usage</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1858r2.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1858r2.html</a><br/>
<br/>
<h2 id="ancillary-references">Ancillary References</h2>
<span id="reference-p1371r2">What is a “callback” in C and how are they implemented?</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://stackoverflow.com/questions/142789/what-is-a-callback-in-c-and-how-are-they-implemented" target="__blank">https://stackoverflow.com/questions/142789/what-is-a-callback-in-c-and-how-are-they-implemented</a><br/>
<br/>
<span id="reference-p1371r2">Using A C++ Object’s Member Function with C-style Callbacks</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://embeddedartistry.com/blog/2017/07/10/using-a-c-objects-member-function-with-c-style-callbacks/" target="__blank">https://embeddedartistry.com/blog/2017/07/10/using-a-c-objects-member-function-with-c-style-callbacks/</a><br/>
<br/>
<span id="reference-p1371r2">Callback (computer programming)</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://en.wikipedia.org/wiki/Callback_(computer_programming)" target="__blank">https://en.wikipedia.org/wiki/Callback_(computer_programming)</a><br/>
<br/>
<span id="reference-p1371r2">Function object</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://en.wikipedia.org/wiki/Function_object" target="__blank">https://en.wikipedia.org/wiki/Function_object</a><br/>
<br/>
<span id="reference-p1371r2">C++ Delegates and Borland's C++ Builder Event Handling - Part I</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://www.codeproject.com/Articles/44874/C-Delegates-and-Borland-s-C-Builder-Event-Handling" target="__blank">https://www.codeproject.com/Articles/44874/C-Delegates-and-Borland-s-C-Builder-Event-Handling</a><br/>
<br/>
<span id="reference-p1371r2">Delegates (C# Programming Guide)</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/" target="__blank">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/</a><br/>
<br/>
<span id="reference-p1371r2">On function_ref and string_view</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://quuxplusone.github.io/blog/2019/05/10/function-ref-vs-string-view/" target="__blank">https://quuxplusone.github.io/blog/2019/05/10/function-ref-vs-string-view/</a><br/>
<br/>
<span id="reference-p1371r2">How to pass and execute anonymous function as parameter in C++11?</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://newbedev.com/how-to-pass-and-execute-anonymous-function-as-parameter-in-c-11" target="__blank">https://newbedev.com/how-to-pass-and-execute-anonymous-function-as-parameter-in-c-11</a><br/>
<br/>
<span id="reference-p1371r2">Passing Functions to Functions in C++</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://tech.jocodoma.com/2019/02/27/Passing-Functions-to-Functions-in-CPP/" target="__blank">https://tech.jocodoma.com/2019/02/27/Passing-Functions-to-Functions-in-CPP/</a><br/>
<br/>
<span id="reference-p1371r2">passing functions to functions</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://vittorioromeo.info/index/blog/passing_functions_to_functions.html">https://vittorioromeo.info/index/blog/passing_functions_to_functions.html</a><br/>
<br/>
<span id="reference-p1371r2">function_view: a non-owning reference to a Callable</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://vittorioromeo.info/Misc/fnview0.html" target="__blank">https://vittorioromeo.info/Misc/fnview0.html</a><br/>
<br/>
<span id="reference-p1371r2">Alternative to std::function for passing function as argument (callbacks, etc.)</span><br/>
&nbsp;&nbsp;&nbsp;<a href="https://stackoverflow.com/questions/39087141/alternative-to-stdfunction-for-passing-function-as-argument-callbacks-etc" target="__blank">https://stackoverflow.com/questions/39087141/alternative-to-stdfunction-for-passing-function-as-argument-callbacks-etc</a><br/>
<br/>
<span id="reference-p1371r2">Packs outside of Templates</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2277r0.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2277r0.html</a><br/>
<br/>
<span id="reference-p1371r2">A type trait to detect reference binding to temporary</span><br/>
&nbsp;&nbsp;&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2255r0.html" target="__blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2255r0.html</a><br/>
</body>
</html>
