<!DOCTYPE html><html><head><meta charset="utf-8"><title>Markdown Plus exported HTML</title><link rel="stylesheet" href="https://cdn.rawgit.com/tylingsoft/markdown-core/0.7.0/dist/markdown-core.min.css"></head><body><article class="markdown-body"><style type="text/css">
ins { background-color: #CCFFCC }
s { background-color: #FFCACA }
blockquote { color: inherit !important }
</style>
<table>
<tbody><tr>
<td>Document number</td>
<td>D****R0</td>
</tr>
<tr>
<td>Date</td>
<td>2022-06-26</td>
</tr>
<tr>
<td>Reply-to</td>
<td>
<p>Jarrad J. Waterloo &lt;descender76 at gmail dot com&gt;</p>
</td>
</tr>
<tr>
<td>Audience</td>
<td>Evolution Working Group (EWG)</td>
</tr>
</tbody></table>
<h1 id="implicit-constant-initialization"><a class="anchor" href="#implicit-constant-initialization"><span class="octicon octicon-link"></span></a>implicit constant initialization</h1>
<style>
.inline-link
{
    font-size: small;
    margin-top: -2.8em;
    margin-right: 4px;
    text-align: right;
    font-weight: bold;
}

code
{
    font-family: "Fira Code", monospace !important;
    font-size: 0.87em;
}

.sourceCode
{
    font-size: 0.95em;
}

a code
{
    color: #0645ad;
}
</style>
<!--

  - [The conditions](#the-conditions)
    - [Expectations](#expectations)

    - [Future](#future)
      - [Proposal #1: `C++` with `static storage duration`](#proposal-1-c-with-static-storage-duration)
      - [Proposal #2: `C` `compound literals` with `static storage duration`](#proposal-2-c-compound-literals-with-static-storage-duration)
      - [Optional Addendum #1 - Deduplication](#optional-addendum-1-deduplication)
      - [Optional Addendum #2 - Undefined Strings](#optional-addendum-2-undefined-strings)
      - [Optional Addendum #3 - Arrays](#optional-addendum-3-arrays)
      - [Optional Addendum #4 - Address of literal](#optional-addendum-4-address-of-literal)
      - [Optional Addendum #5 - Delayed Initialization](#optional-addendum-5-delayed-initialization)
-->
<h2 id="table-of-contents"><a class="anchor" href="#table-of-contents"><span class="octicon octicon-link"></span></a>Table of contents</h2>
<ul>
<li><a href="#implicit-constant-initialization">implicit constant initialization</a>
<ul>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#motivating-examples">Motivating examples</a>
<ul>
<li><a href="#value-categories">Value Categories</a></li>
<li><a href="#storage-duration">Storage Duration</a></li>
<li><a href="#constant-expressions">Constant Expressions</a></li>
<li><a href="#constant-initialization">Constant Initialization</a></li>
<li><a href="#a-common-example">A common example</a></li>
</ul>
</li>
<li><a href="#the-conditions">The conditions</a></li>
<li><a href="#why-not-before">Why not before</a></li>
<li><a href="#other-languages">Other languages</a></li>
<li><a href="#impact-on-current-proposals">Impact on current proposals</a>
<ul>
<li><a href="#p2255r2">p2255r2</a></li>
<li><a href="#p2576r0">p2576r0</a></li>
</ul>
</li>
<li><a href="#rationale">Rationale</a>
<ul>
<li><a href="#past">Past</a>
<ul>
<li><a href="#n1511">n1511</a></li>
<li><a href="#n2235">n2235</a></li>
</ul>
</li>
<li><a href="#present">Present</a>
<ul>
<li><a href="#c-standard-compund-literals">C Standard Compound Literals</a></li>
<li><a href="#c-standard">C++ Standard</a></li>
<li><a href="#outstanding-issues">Outstanding Issues</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#summary">Summary</a></li>
<li><a href="#frequently-asked-questions">Frequently Asked Questions</a></li>
<li><a href="#references">References</a></li>
</ul>
</li>
</ul>
<!--
  - [Ancillary examples](#ancillary-examples)
-->
<h2 id="abstract"><a class="anchor" href="#abstract"><span class="octicon octicon-link"></span></a>Abstract</h2>
<p>This document proposes enhancements to <code>constant initialization</code> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> to decrease the shock of working with constants, literals and constant like expressions in C++ with the ultimate goal of reducing the frequency of encountering dangling references.</p>
<h2 id="motivating-examples"><a class="anchor" href="#motivating-examples"><span class="octicon octicon-link"></span></a>Motivating Examples</h2>
<p>There is a general expectation across programming languages that constants or more specifically constant literals are "immutable values which are known at compile time and do not change for the life of the program".  <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> In most programming languages or rather the most widely used programming languages, constants do not dangle. Constants are so simple, so trivial (English wise), that it is shocking to even have to be conscience of dangling. This is shocking to <code>C++</code> beginners, expert programmers from other programming languages who come over to <code>C++</code> and at times even shocking to experienced <code>C++</code> programmers. The shock is not limited to dangling, though that is the greater one, when it does happen. There are also seemingly inconsistencies with respect to <code>storage durations</code> and <code>value categories</code>.</p>
<h3 id="value-categories"><a class="anchor" href="#value-categories"><span class="octicon octicon-link"></span></a>Value Categories</h3>
<p>According to <code>cppreference.com</code> <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>, all literals are prvalue expressions except for string literals which are lvalue expressions.</p>
<p><strong><em>lvalue</em></strong></p>
<p><em>The following expressions are lvalue expressions:</em></p>
<ul>
<li><em>a string literal, such as "Hello, world!";</em></li>
</ul>
<p><strong><em>prvalue</em></strong></p>
<p><em>The following expressions are prvalue expressions:</em></p>
<ul>
<li><em>a literal (except for string literal), such as 42, true or nullptr;</em></li>
</ul>
<p><strong>Should a beginner <code>C++</code> programmer need to know <code>value categories</code> in order to create and use constants safely!</strong> Besides the seeming inconsistency, I mention value categories because what is being proposed may require fine tuning the value catgories of literals. Accepting this proposal might mean that non string literals will be lvalue when they are constant expressions and prvalue when they are not constant expressions. If this proposal is ever combined with <code>Bind Returned/Initialized Objects to the Lifetime of Parameters</code> <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> then string literals might also be lvalue when they are constant expressions and prvalue, with automatic storage duration, when they are not constant expressions. Combined, this could unify the behavior of literals, moving the seeming inconsistency from the type of the literal to the constness of the literal were it makes more sense and more valuable from a dangling stand point.</p>
<h3 id="storage-duration"><a class="anchor" href="#storage-duration"><span class="octicon octicon-link"></span></a>Storage Duration</h3>
<p>According to <code>cppreference.com</code> <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>, <em>"string literals have static storage duration, and thus exist in memory for the life of the program."</em> All the other types of literals have automatic storage duration by default. While that may makes perfect sense for literals that are not constant, constants on other hand are generally believed to be the same value for the life of the program and are ideal candidates to have static storage duration so they can exist in memory for the life of the program. Since literals currently don't behave this way, constant [like] literals are not as simple as they could be, leading to superfluous dangling.</p>
<table>
<tbody><tr>
<td>
<p><strong>non dangling</strong></p>
</td>
<td>
<p><strong>dangling</strong></p>
</td>
</tr>
<tr>
<td>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">non_dangling_42</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* constant = <span class="hljs-string">"42"</span>;
    <span class="hljs-keyword">return</span> constant;
}</code></pre></td>
<td>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">dangling_42</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> constant = <span class="hljs-number">42</span>;
    <span class="hljs-comment">//static const int constant = 42;// FIX</span>
    <span class="hljs-keyword">return</span> constant;
}</code></pre></td>
</tr>
<tr>
<td>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">maybe_dangling_42</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* maybe_constant)</span>
</span>{
    <span class="hljs-keyword">return</span> maybe_constant;
}

maybe_dangling_42(<span class="hljs-string">"42"</span>);<span class="hljs-comment">// NOT dangling</span></code></pre></td>
<td>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">maybe_dangling_42</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; maybe_constant)</span>
</span>{
    <span class="hljs-keyword">return</span> maybe_constant;
}

<span class="hljs-comment">// dangling because </span>
<span class="hljs-comment">// 42 is auto not static storage duration unlike string literal</span>
<span class="hljs-comment">// 42's lifetime is statement not enclosing block unlike C literal</span>
maybe_dangling_42(<span class="hljs-number">42</span>);</code></pre></td>
</tr>
</tbody></table>
<p>Even though the usage is the same, the constant string examples do not dangle because they have static storage duration while the dangling, non string literal has automatic storage duration.</p>
<h3 id="constant-expressions"><a class="anchor" href="#constant-expressions"><span class="octicon octicon-link"></span></a>Constant Expressions</h3>
<p><code>C++ Core Guidelines: Programming at Compile Time with constexpr</code> <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p>
<p><em>"A constant expression"</em></p>
<ul>
<li><em>"<strong>can</strong> be evaluated at <strong>compile time</strong>."</em></li>
<li><em>"give the compiler deep insight into the code."</em></li>
<li><em>"are implicitly thread-safe."</em></li>
<li><em>"<strong>can</strong> be constructed in the <strong>read-only memory (ROM-able)</strong>."</em></li>
</ul>
<p>It isn't just that resolved constant expressions <strong>can</strong> be placed in ROM which makes programmers believe these <strong>should</strong> be stored globally but also the fact that fundamentally <strong>these expressions are executed at compile time</strong>. Along with templates, constant expressions are the closest thing <code>C++</code> has to <strong>pure</strong> functions. That means the results are the same given the parameters, and since these expressions run at compile time, than the resultant values are the same, no matter where or when in the <code>C++</code> program. This is essentially global to the program; technically across programs too.</p>
<p>This proposal just requests, at least in specific scenarios, that instead of resolved constant expressions <strong>CAN</strong> be ROMable but rather that they <strong>HAVE</strong> to be or at least the next closest thing; constant and <code>static storage duration</code>.</p>
<h3 id="constant-initialization"><a class="anchor" href="#constant-initialization"><span class="octicon octicon-link"></span></a>Constant Initialization</h3>
<p>According to <code>cppreference.com</code> <sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>, the syntax for <code>constant initialization</code> <sup class="footnote-ref"><a href="#fn1" id="fnref1:2">[1:2]</a></sup> is as follows:</p>
<pre><code class="hljs"><span class="hljs-keyword">static</span> T &amp; ref = <span class="hljs-keyword">constexpr</span>;

<span class="hljs-keyword">static</span> T object = <span class="hljs-keyword">constexpr</span>;</code></pre><p>For the sake of this proposal, I am currently only talking about a subset of <code>constant initialization</code> where T is const since the primary focus is on constants.</p>
<pre><code class="hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> T &amp; ref = <span class="hljs-keyword">constexpr</span>;

<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> T object = <span class="hljs-keyword">constexpr</span>;</code></pre><p>Ironically, at namespace scope, variables are already implicitly static and as such the previous example could simply be written as the following:</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> T &amp; ref = <span class="hljs-keyword">constexpr</span>;

<span class="hljs-keyword">const</span> T object = <span class="hljs-keyword">constexpr</span>;</code></pre><!--
6.7.5.2 Static storage duration
namespace sope is already implicitly static
technically I am only talking about static const
and still temporary
-->
<p>Unfortunately, the static storage duration doesn't come from the fact that it is a constant expression and that a constant was expected/requested. Consider for a moment, if it did, that is implicit static storage duration by looking at this from a constant definition in a class, a function body and parameters/arguments.</p>
<h4 id="constant-definition-in-class-definitions"><a class="anchor" href="#constant-definition-in-class-definitions"><span class="octicon octicon-link"></span></a>constant definition in class definitions</h4>
<pre><code class="hljs"><span class="hljs-keyword">struct</span> S
{
  <span class="hljs-keyword">const</span> T &amp; ref = <span class="hljs-keyword">constexpr</span>;
  <span class="hljs-keyword">const</span> T object = <span class="hljs-keyword">constexpr</span>;
};</code></pre><p>If the class members <code>ref</code> and <code>object</code> were implicitly made static the result to class <code>S</code> would be a reduction in size and initialization time. The class members <code>ref</code> and <code>object</code> would still be <code>const</code> and their respective types, so their should be no change in the logic of the code that directly depends upon them. While supporting implicit static storage duration here does not decrease dangling, it would be of benefit from a language simplicitly standpoint for this to be consistent with the next two sections; function body and their parameters and arguments. However since this section has to do with class data member definition and not code execution, explicit static could still be required, if their is a real and significent concern over code breakage.</p>
<h4 id="constant-definition-in-function-body"><a class="anchor" href="#constant-definition-in-function-body"><span class="octicon octicon-link"></span></a>constant definition in function body</h4>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">dangling_42</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; constant = <span class="hljs-number">42</span>;
    <span class="hljs-keyword">return</span> constant;
}

<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">dangling_42</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> constant = <span class="hljs-number">42</span>;
    <span class="hljs-keyword">return</span> constant;
}

<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">dangling_42</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
}</code></pre><p>With implicit static storage duration, these examples would not dangle and would make more sense. The local variable <code>constant</code> and even unnamed variable, temporary, <code>42</code>, still is <code>const</code> and have their respective types, so their should be no change in the logic of the code that directly depends upon them. As such, this feature isn't expected to break existing code.</p>
<h4 id="constant-definition-in-function-parameter-and-arguments"><a class="anchor" href="#constant-definition-in-function-parameter-and-arguments"><span class="octicon octicon-link"></span></a>constant definition in function parameter and arguments</h4>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">maybe_dangling_42</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; maybe_constant)</span></span>;

maybe_dangling_42(<span class="hljs-number">42</span>);</code></pre><p>This is expected to be a non breaking change because a parameter that takes a const&amp; argument doesn't know whether the instance was created locally, statically or even dynamically. The advantage of adding implicit constant initialization here would be that those temporary const argument scenarios would no longer dangle. Static storage duration for arguments is actually the primary goal of this paper. It should also be noted that while <code>static</code> can be applied explicitly in class data member definition and in function bodies, static isn't even an option as a modifier to a function argument, so the user doesn't have a choice and the current default of automatic storage duration instead of static storage duration is less intuitive when constants of constant expressions are involved. Even if the keyword <code>static</code> could be applied to arguments, programmer's code will be littered with that keyword as they will start applying it to every argument initialized in a constant expression fashion.</p>
<!--

### C++20

This should be able to force static storage duration for arguments.

https://en.cppreference.com/w/cpp/language/template_parameters

```cpp
template<auto constant_expression>
const auto constant()
{
    return &constant_expression;
}

some_function(constant<constant_expression>());
```

-->
<h3 id="a-common-example"><a class="anchor" href="#a-common-example"><span class="octicon octicon-link"></span></a>A common example</h3>
<p>After applying this proposal and ensuring <code>std::string_view</code> and other reference types have a <code>constexpr</code> constructor that can take <code>const</code> parameters. Does the following example still dangle?</p>
<pre><code class="hljs"><span class="hljs-built_in">std</span>::string_view sv = <span class="hljs-string">"hello world"</span>s;<span class="hljs-comment">// immediate dangling reference</span></code></pre><!--
Example

// x86-64 clang (trunk)
// -std=c++20 -O2 -Wdangling-gsl
#include <iostream>
#include <string>

using namespace std::string_literals;

int main() {
    std::string_view sv = "hello world"s;
    std::cout << sv << std::endl;
    return 42;
}
-->
<p>It is clear from this <code>string_view</code> example that it dangles because <code>sv</code> is a reference and <code>""s</code> is a temporary.
<strong><em>What is being proposed is that same example doesn't dangle!</em></strong>
If the constant expression <code>"hello world"s</code> was promoted to static storage duration then <code>sv</code> could be a reference to something that is global and as such would not dangle. This is reasonable based on how users reason about constants, safer because of less dangling and simpler because something as simple as constants shouldn't dangle.</p>
<!--

That given simple reasonable conditions, the lifetime of the temporary gets automatically extended.

## The conditions

1. the argument would, prior to this proposal, be a temporary
1. the type of the parameter is a constant reference or constant pointer
1. type of the temporary argument has a constexpr constructor
1. **[Optional]** type of the temporary argument has compile time comparison; constexpr <=>

What is being proposed is that the storage duration of the argument, under these specific conditions, be changed from automatic to static!
In other words, the temporary argument would be constructed with the constexpr constructor, stored statically in read only memory and automatically deduplicated if this unnamed constant expression was used more than once provided the type has an optional `constexpr` spaceship operator.

This is reasonable because a constant reference/pointer parameter doesn't care how the object was constructed. Further, if the compiler has the choice to constexpr construct the object once rather than repeatedly throughout the execution of the program, than why wouldn't a developer want that.

This feature is also similar to existing features/concepts that programmers are familiar with. This feature is an implicit anonymous `constant`. It is more like an implicit anonymous `static local`. Really, at the end of the day, it is just another literal. For new `C++` programmers, old programmers from other programming languages and even old `C++` programmers it can be surprising when something as simple and trivial as a literal fails. No less, why one has to be overly attentive to it in the first place.

There is interest in eliminating, if not reducing dangling references. Consider:

1. `Why lifetime of temporary doesn't extend till lifetime of enclosing object?` [^soauto]
1. `Bind Returned/Initialized Objects to the Lifetime of Parameters` [^bindp]
1. `Lifetime safety: Preventing common dangling` [^lifetimesafety]

These talks about identify such issues but this proposal would address a small portion of them especially ones that would be considered surprising to programmers.

-->
<h2 id="why-not-before"><a class="anchor" href="#why-not-before"><span class="octicon octicon-link"></span></a>Why not before</h2>
<p>Only recently have we had all the pieces to make this happen. Further there is greater need now that more types are getting constexpr constructors. Also types that would normally only be dynamically allocated, such as string and vector, since <code>C++20</code>, can also be <code>constexpr</code>. This has opened up the door wide for many more types being constructed at compile time.</p>
<p><strong>C++11</strong></p>
<ul>
<li>constexpr</li>
</ul>
<p><strong>C++14</strong></p>
<ul>
<li>relaxed constexpr restrictions</li>
</ul>
<p><strong>C++20</strong></p>
<ul>
<li>The spaceship operator</li>
<li><code>Making std::string constexpr</code> <sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup></li>
<li><code>Making std::vector constexpr</code> <sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup></li>
</ul>
<p><strong>C++23</strong></p>
<ul>
<li><code>P2255R2 (A type trait to detect reference binding to temporary)</code> <sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup></li>
<li><code>Missing constexpr in std::optional and std::variant</code> <sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup></li>
<li><code>Making std::unique_ptr constexpr</code> <sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup></li>
</ul>
<p>Since <code>C++11</code>, constexpr has continued to gain ground but the final pieces of the feature has only recently landed with stronger comparison via the spaceship operator in C++20 and, if it makes it, the ability to detect temporaries in <code>C++23</code>.</p>
<h2 id="other-languages"><a class="anchor" href="#other-languages"><span class="octicon octicon-link"></span></a>Other languages</h2>
<h3 id="many-native-languages"><a class="anchor" href="#many-native-languages"><span class="octicon octicon-link"></span></a>many native languages</h3>
<p>Many native languages, including C and C++, already provide this capability by storing said instances in the <code>COFF String Table</code> of the <code>portable executable format</code> <sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>.</p>
<h3 id="java"><a class="anchor" href="#java"><span class="octicon octicon-link"></span></a>Java</h3>
<p>Java automatically perform interning on its <code>String class</code> <sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>.</p>
<h3 id="c-and-other-net-languages"><a class="anchor" href="#c-and-other-net-languages"><span class="octicon octicon-link"></span></a>C# and other .NET languages</h3>
<p>The .NET languages also performs interning on its <code>String class</code> <sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup></p>
<h3 id="many-other-languages"><a class="anchor" href="#many-other-languages"><span class="octicon octicon-link"></span></a>many other languages</h3>
<p>According to Wikipedia's article, <code>String interning</code> <sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>, Python, PHP, Lua, Ruby, Julia, Lisp, Scheme, Smalltalk and Objective-C's each has this capability in one fashion or another.</p>
<p>What is proposed here is increasing the interning that C++ already does, but is not limited to just strings, in order to reduce dangling references. The fact is, literals in <code>C++</code> is needless complicated with clearly unnecessary memory safety issues that impedes programmers coming to <code>C++</code> from other languages, even <code>C</code>.</p>
<!--

## Ancillary Examples

```cpp
void some_function(const char*);

// native strings can also be created at compile time
some_fuction("hello world");
```

---

```cpp
void some_function(const std::string&);

// As of C++20, std::string can be constructed constexpr
some_fuction("hello world"s);
```

---

```cpp
void some_function(const std::vector<std::string>&);

// As of C++20, std::vector and std::string can be constructed constexpr
some_fuction({"hello", "world"});
```

---

```cpp
void some_function(const std::optional<std::string>&);

// As of C++23, std::optional and std::string can be constructed constexpr
some_fuction("hello world"s);
```

---

```cpp
void some_function(const std::variant<std::string>&);

// As of C++23, std::variant and std::string can be constructed constexpr
some_fuction("hello world"s);
```

---

```cpp
void some_function(const std::unique_ptr<std::string>&);

// As of C++23, std::unique_ptr can be constructed constexpr
some_fuction(std::make_unique<std::string>("hello world"));
```

-->
<h2 id="impact-on-current-proposals"><a class="anchor" href="#impact-on-current-proposals"><span class="octicon octicon-link"></span></a>Impact on current proposals</h2>
<h3 id="p2255r2"><a class="anchor" href="#p2255r2"><span class="octicon octicon-link"></span></a>p2255r2</h3>
<p><strong><em><code>A type trait to detect reference binding to temporary</code></em></strong> <sup class="footnote-ref"><a href="#fn9" id="fnref9:1">[9:1]</a></sup></p>
<p>Following is a slightly modified <code>constexpr</code> example taken from the <code>p2255r2</code> <sup class="footnote-ref"><a href="#fn9" id="fnref9:2">[9:2]</a></sup> proposal. Only the suffix <code>s</code> has been added. It is followed by a non <code>constexpr</code> example. Currently, such an example is immediately dangling. Via <code>p2255r2</code> <sup class="footnote-ref"><a href="#fn9" id="fnref9:3">[9:3]</a></sup>, both examples become ill formed. However, with this proposal the <code>constexpr</code> example becomes valid.</p>
<table>
<tbody><tr>
<td>
</td>
<td>
<p><strong>constexpr</strong></p>
</td>
<td>
<p><strong>runtime</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>Examples</strong></p>
</td>
<td>
<pre><code class="hljs"><span class="hljs-built_in">std</span>::tuple&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp;&gt; x(<span class="hljs-string">"hello"</span>s);</code></pre></td>
<td>
<pre><code class="hljs"><span class="hljs-built_in">std</span>::tuple&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp;&gt; x(factory_of_string_at_runtime());</code></pre></td>
</tr>
<tr>
<td>
<p><strong>Before</strong></p>
</td>
<td>
<pre><code class="hljs"><span class="hljs-comment">// dangling</span></code></pre></td>
<td>
<pre><code class="hljs"><span class="hljs-comment">// dangling</span></code></pre></td>
</tr>
<tr>
<td>
<p><code>p2255r2</code> <sup class="footnote-ref"><a href="#fn9" id="fnref9:4">[9:4]</a></sup></p>
</td>
<td>
<pre><code class="hljs"><span class="hljs-comment">// ill-formed</span></code></pre></td>
<td>
<pre><code class="hljs"><span class="hljs-comment">// ill-formed</span></code></pre></td>
</tr>
<tr>
<td>
<p><code>p2255r2</code> <sup class="footnote-ref"><a href="#fn9" id="fnref9:5">[9:5]</a></sup> and this proposal</p>
</td>
<td>
<pre><code class="hljs"><span class="hljs-comment">// correct</span></code></pre></td>
<td>
<pre><code class="hljs"><span class="hljs-comment">// ill-formed</span></code></pre></td>
</tr>
</tbody></table>
<p>The proposed valid example is reasonable from many programmers perspective because <code>"hello"s</code> is a literal just like <code>"hello"</code> is a safe literal in C++ and C99 compound literals are <strong>safer</strong> literals because the lifetime is the life of the block instead of the expression. More on that latter.</p>
<h3 id="p2576r0"><a class="anchor" href="#p2576r0"><span class="octicon octicon-link"></span></a>p2576r0</h3>
<p><strong><em><code>The constexpr specifier for object definitions</code></em></strong> <sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup></p>
<p>The <code>p2576r0</code> <sup class="footnote-ref"><a href="#fn16" id="fnref16:1">[16:1]</a></sup> proposal is about contributing <code>constexpr</code> back to the <code>C</code> programming language. Interestingly, <code>C++</code> has <code>constexpr</code> in the first place, in part, to allow <code>C99</code> compound literals in <code>C++</code>. In the <code>p2576r0</code> <sup class="footnote-ref"><a href="#fn16" id="fnref16:2">[16:2]</a></sup> proposal there are numerous references to "constant expression" and "static storage duration" highlighting that this and my proposal are playing in the same playground. Consider the following:</p>
<p><em>"C requires that objects with static storage duration are only initialized with constant expressions.</em></p>
<p><em>"Because C limits initialization of objects with static storage duration to constant expressions, it can be difficult to create clean abstractions for complicated value generation."</em></p>
<p>Further, the <code>p2576r0</code> <sup class="footnote-ref"><a href="#fn16" id="fnref16:3">[16:3]</a></sup> proposal has a whole section devoted to just storage duration.</p>
<p><em>"3.4. Storage duration"</em></p>
<p><em>"For the storage duration of the created objects we go with C++ for compatibility, that is per default we have automatic in block scope and static in file scope. The default for block scope can be overwritten by static or refined by register. It would perhaps be more natural for named constants"</em></p>
<ul>
<li><em>"to be addressless (similar to a register declaration or an enumeration),"</em></li>
<li><em>"to have static storage duration (imply static even in block scope), or"</em></li>
<li><em>"to have no linkage (similar to typedef or block local static)"</em></li>
</ul>
<p><em>"but we decided to go with C++’s choices for compatibility."</em></p>
<p>My proposal would constitute a delay in the <code>p2576r0</code> <sup class="footnote-ref"><a href="#fn16" id="fnref16:4">[16:4]</a></sup> proposal as I am advocating for refining the <code>C++</code> choices before contributing <code>constexpr</code> back to <code>C</code>. I also believe that the <code>p2576r0</code> <sup class="footnote-ref"><a href="#fn16" id="fnref16:5">[16:5]</a></sup> proposal fails to consider a fourth alternative with respect to storage duration and that is to go with how <code>C</code> handles compound literals and have <code>C++</code> to conform with it. This will be considered momentarily.</p>
<h2 id="rationale"><a class="anchor" href="#rationale"><span class="octicon octicon-link"></span></a>Rationale</h2>
<!--

### Expectations

There is a general expectation that constant expressions are already of static storage duration. While that is partially wrong, that expectation is still there. Consider the following examples. Everywhere you see ROMable, you might as well say constant and global/static.

**December 19, 2012**

`Using constexpr to Improve Security, Performance and Encapsulation in C++` [^smartbear]

*"One of the advantages of **user-defined literals** with a small memory footprint is that an implementation can store them in the system’s **ROM**. Without a **constexpr constructor**, the object would require dynamic initialization and therefore wouldn’t be **ROM-able**."*

...

*"**Compile-time evaluation of expressions** often leads to more efficient code and enables the compiler to store the result in the system’s **ROM**."*

**May 21, 2015**

`Bitesize Modern C++ : constexpr` [^bitesize]

*"**ROM-able** types"*

...

*"<u>Since everything required to construct the **Rommable** object is known at **compile-time** it can be constructed in **read-only memory**.</u>"*

**4 February 2019**

`C++ Core Guidelines: Programming at Compile Time with constexpr` [^guidelines]

*"A constant expression"*

-  *"**can** be evaluated at **compile time**."*
-  *"give the compiler deep insight into the code."*
-  *"are implicitly thread-safe."*
-  *"**can** be constructed in the **read-only memory (ROM-able)**."*

It isn't just that resolved constant expressions **can** be placed in ROM which makes programmers believe these **should** be stored globally but also the fact that fundamentally **these expressions are executed at compile time**. Along with templates, constant expressions are the closest thing `C++` has to **pure** functions. That means the results are the same given the parameters, and since these expressions run at compile time, than the resultant values are the same, no matter where or when in the `C++` program. This is essentially global to the program; technically across programs too.

This proposal just requests that at least in specific scenarios that instead of resolved constant expressions **CAN** be ROMable but rather that they **HAVE** to be or at least the next closest thing; constant and `static storage duration`.

Let's also consider the view of compiler writers briefly.

**Asked 9 years, 10++ months ago**

`How can I get GCC to place a C++ constexpr in ROM?` [^gccconstexprrom]

...

*"As far as I understand the ffx object in the code below should end up in **ROM (code)**, but instead it is placed in **DATA**."*

...

*"This is indeed fixed in gcc 4.7.0"*

So there is at least some understanding among compiler writers that instances produced from constexpr expressions
were ROMable. What is more interesting is that it doesn't matter if it is in the ROM/code/text segment or the DATA segment, it is still global regardless of which. One is just read only. If we can guarantee `static storage duration` for constant temporaries we can reduce danglings.

-->
<h3 id="past"><a class="anchor" href="#past"><span class="octicon octicon-link"></span></a>Past</h3>
<p>A brief consideration of the proposals that led to <code>constexpr</code> landing as a feature in <code>C++11</code> bears weight on the justification of refining constant initialization.</p>
<h4 id="n1511"><a class="anchor" href="#n1511"><span class="octicon octicon-link"></span></a>n1511</h4>
<p><strong><em><code>Literals for user-defined types</code></em></strong> <sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup></p>
<p><strong>2003</strong></p>
<p><em>"This note proposes a notion of <strong>user-defined literals</strong> based on literal constructors without requiring new syntax. If combined with the separate proposal for generalized initializer lists, it becomes a generalization of the <strong>C99 notion of compound literals</strong>."</em></p>
<p><em>"However, a constructor is a very general construct and there have been many requests for a way to express literals for user-defined types in such a way that a programmer can be <strong>confident that a value <u>will be</u> constructed at compile time</strong> and <strong>potentially stored in ROM</strong>. For example:"</em></p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">complex</span> <span class="hljs-title">z</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// the variable z can be constructed at compile time</span>
<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">complex</span> <span class="hljs-title">cz</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// the const cz can potentially be put in ROM</span></code></pre><p><em>"<strong>Personally, I prefer (1): basically, a value is a literal if it is composed out of literals and implemented by a literal constructor. The problem with that is that some people will not trust compilers to do proper resolution, placement in ROM, placement in text segment</strong>, etc. Choosing that solution would require text in the standard to constrain and/or guide implementations."</em></p>
<p><em>"<strong>C99 compound literals</strong>"</em></p>
<p><em>"In C99, it is explicitly allowed to take the address of a compound literal. For example:"</em></p>
<pre><code class="hljs">f(&amp;(<span class="hljs-keyword">struct</span> foo) { <span class="hljs-number">1</span>,<span class="hljs-number">2</span> });</code></pre><p><em>"<strong>This makes sense only if we assume that the {1,2} is stored in a data segment (like a string literal</strong>, but different from a int literal). <strong>I see no problem allowing that, as long as it is understood that unless &amp; is explicitly used or the literal, a user-defined literal is an rvalue</strong> with which the optimizer has a free hand."</em></p>
<p><em>"<strong>It would be tempting to expand this rule to user-defined literals bound to references.</strong> For example:"</em></p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">complex</span>&amp;)</span></span>;
 <span class="hljs-comment">// …</span>
 f(<span class="hljs-keyword">complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)); <span class="hljs-comment">// ok?</span></code></pre><p><em>"However, this would touch upon some rather brittle parts of the overload resolution rules to do with rvalue vs. lvalue. For example:"</em></p>
<pre><code class="hljs"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
 <span class="hljs-comment">// ...</span>
 <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;().swap(v); <span class="hljs-comment">// ok</span>
 swap(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(), v); <span class="hljs-comment">// would become ok</span></code></pre><p><em>"I suggest we don’t touch this <strong>unless we are looking at the rvalue/lvalue rules for other reasons.</strong>"</em></p>
<p>The other reason why we should re-evaluate user-defined literals bound to references is to reduce dangling references and even dangling pointers. It is also surprising that user defined literals do not work simply without memory issues and that they currently work better in C and practically in every other language than it does in C++. ROM, read only memory, is effectively global/static storage duration and const. Note too that the original motivation for constant expressions are for literals. So constant expressions are effectively literals. Note also the following example provided in that proposal.</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">complex</span> <span class="hljs-title">z</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// the variable z can be constructed at compile time</span>
<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">complex</span> <span class="hljs-title">cz</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// the const cz can potentially be put in ROM</span></code></pre><p>While both constant expressions are the same, the detail that decides whether it is a literal that can even be placed in ROM was the <code>const</code> keyword. So, <code>const</code> constant expressions are constant literals or simply, constants.</p>
<!--
It wouldn't hurt to fix any brittle rules and in the 10++ years since we got `constexpr` some of these may have already been fixed and it could be time to review these finer points.

Even if these brittle concerns haven't already been addressed, two things could be performed to mitigate these concerns. For instance a automatic conversion from lvalue reference to pointer would allow passing implicit and explicit, via `&`, references to pointer arguments. Along with static duration, `C++` would then support the address of `C99` compound literal syntax.

A more complicated solution for references would require compilers not just to look at 2 types but instead 3: the type of the resolved `constexpr`, the type of the argument and the explicit '&' in front of the `constexpr` when the argument is a pointer.
-->
<h4 id="n2235"><a class="anchor" href="#n2235"><span class="octicon octicon-link"></span></a>n2235</h4>
<p><strong><em><code>Generalized Constant Expressions—Revision 5</code></em></strong> <sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup></p>
<p><strong>2007</strong></p>
<p><em>"This paper generalizes the notion of constant expressions to include constant-expression functions and user-defined literals"</em></p>
<p><em>"The goal is ... to <strong>increase C99 compatibility.</strong>"</em></p>
<p><em>"This paper generalizes the notion of constant expressions to include calls to “sufficiently simple” functions (constexpr functions) and objects of user-defined types constructed from “sufficiently simple” constructors (constexpr constructors.)"</em></p>
<p><em>"<strong>simplify the language</strong> definition in the area of constant expression <strong>to match existing practice</strong>"</em></p>
<p><em>"Any enhancement of the notion of constant expressions has to carefully consider the entanglement of many different notions, but strongly related. Indeed, the notion of constant expression appears in different contexts:"</em></p>
<p><em>"3. Static initialization of objects with static storage."</em></p>
<p><em>"Similarly, we do not propose to change the already complex and subtle distinction between “static initialization” and “dynamic initialization”. However <strong>we strive for more uniform and consistency among related C++ language features and compatibility</strong>"</em></p>
<p><em>"3 Problems"</em></p>
<p><em>"Most of the problems addressed by this proposal have been discussed in previous papers, especially the initial proposal for Generalized Constant Expressions [DR03], the proposal for Literals for user-defined types [Str03], Generalized initializer lists [DRS03], Initializer lists [SDR05]. What follows is a brief summary."</em></p>
<p><em>"3.4 Unexpected dynamic initialization"</em></p>
<p><em>"<strong>However, it is possible to be surprised by expressions that (to someone) “look const” but are not.</strong>"</em></p>
<p><em>"3.5 Complex rules for simple things"</em></p>
<p><em>"The focus of this proposal is to address the issues mentioned in preceding sections. However, discussions in the Core Working Group at the Berlin meeting (April 2006) concluded that the current rules for integral constant expressions are too complicated, and source of several Defect Reports. <strong>Consequently, a “cleanup”, i.e. adoption of simpler, more general rules is suggested.</strong>"</em></p>
<p><em>"4 Suggestions for C++0x"</em></p>
<p><em>"Second, we introduce “literals for user-defined type” based on the notion of constant expression constructors."</em></p>
<p><em>"4.2 Constant-expression data"</em></p>
<p><em>"A constant-expression value is a variable or data member declared with the constexpr specifier."</em></p>
<p><em>"As for other const variables, storage need not be allocated for a constant expression datum, unless its address is taken."</em></p>
<pre><code class="hljs"><span class="hljs-comment">// the &amp;x forces x into memory</span></code></pre><p><em>"When the initializer for an ordinary variable (i.e. not a constexpr) happens to be a constant, the compiler can choose to do dynamic or static initialization (as ever)."</em></p>
<p><em>"Declaring a constructor constexpr will help compilers to identify static initialization and perform appropriate optimizations (like putting literals in read-only memory.) Note that since “ROM” isn’t a concept of the C++ Standard and what to put into ROM is often a quite subtle design decision, this proposal simply allows the programmer to indicate what might be put into ROM (constant-expression data) rather than trying to specify what actually goes into ROM in a particular implementation."</em></p>
<p><em>"We do not propose to make constexpr a storage-class-specifier because it can be combined with either static or extern or register, much like const."</em></p>
<p>Most of these references are given to give us a better idea of the current behavior of constexpr. However, it should be noted that the motivations of this proposal is similar to the motivations for <code>constexpr</code> itself. Mainly ...</p>
<ul>
<li>Increase C99 compatibility</li>
<li>Simplify the language to match existing practice</li>
<li>Lessen the surprise of unreasonable lifetimes by expressions that look and are const</li>
<li>Consequently, a “cleanup”, i.e. adoption of simpler, more general rules</li>
</ul>
<h3 id="present"><a class="anchor" href="#present"><span class="octicon octicon-link"></span></a>Present</h3>
<p>This proposal should also be considered in the light of the current standards. A better idea of our current rules is necessary to understanding how they may be simplied for the betterment of <code>C++</code>.</p>
<h4 id="c-standard-compound-literals"><a class="anchor" href="#c-standard-compound-literals"><span class="octicon octicon-link"></span></a>C Standard Compound Literals</h4>
<p>Let's first look at how literals specifically compound literals behave in <code>C</code>. There is still a gap between <code>C99</code> and <code>C++</code> and closing or reducing that gap would not only increase our compatibility but also reduce dangling.</p>
<p><code>2021/10/18 Meneide, C Working Draft</code> <sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup></p>
<p><em>"6.5.2.5 Compound literals"</em></p>
<p><strong>paragraph 5</strong></p>
<p><em>"The value of the compound literal is that of an unnamed object initialized by the initializer list. If the compound literal occurs outside the body of a function, the object has static storage duration; otherwise, it has <strong>automatic storage duration associated with the enclosing block</strong>."</em></p>
<p>The lifetime of this "enclosing block" is longer than that of <code>C++</code>. In <code>C++</code> under <code>6.7.7 Temporary objects [class.temporary]</code> specifically <code>6.12</code> states a <em>temporary bound to a reference in a new-initializer (7.6.2.8) persists until the completion of the full-expression containing the new-initializer</em>.</p>
<p><code>GCC</code> <sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup> describes the result of this gap.</p>
<p><em>"<strong>In C, a compound literal designates an unnamed object with static or automatic storage duration. In C++, a compound literal designates a temporary object that only lives until the end of its full-expression. As a result, well-defined C code that takes the address of a subobject of a compound literal can be undefined in C++</strong>, so G++ rejects the conversion of a temporary array to a pointer."</em></p>
<p>Simply put <code>C</code> has fewer dangling than <code>C++</code>. What is more is that <code>C</code>'s  solution covers both const and non const temporaries! Even though it is <code>C</code>, it is more like <code>C++</code> than what people give this feature credit for because it is tied to blocks/braces, just like RAII. This adds more weight that the <code>C</code> way is more intuitive. Consequently, the remaining dangling should be easier to spot for developers not having to look at superfluous dangling.</p>
<p>GCC even takes this a step forward which is closer to what this proposal is advocating. The last reference also says the following.</p>
<p><em>"<strong>As a GNU extension, GCC allows initialization of objects with static storage duration by compound literals (which is not possible in ISO C99 because the initializer is not a constant).</strong> It is handled as if the object were initialized only with the brace-enclosed list if the types of the compound literal and the object match. <strong>The elements of the compound literal must be constant.</strong> If the object being initialized has array type of unknown size, the size is determined by the size of the compound literal."</em></p>
<p>The <code>C++</code> standard likely recognized that their are other opportunities for constant initialization. For instance, <code>cppreference</code> highlighted this possibility.</p>
<p><em>The compiler is permitted to initialize other static and thread-local (since C++11) objects using constant initialization, if it can guarantee that the value would be the same as if the standard order of initialization was followed.</em> <sup class="footnote-ref"><a href="#fn1" id="fnref1:3">[1:3]</a></sup></p>
<p>This proposal is one such opportunity. Besides improving constant initialization, we'll be increasing memory safety by reducing dangling.</p>
<p><strong>Should <code>C++</code> just adopt <code>C99</code> literal lifetimes being scoped to the enclosing block instead of to the <code>C++</code> statement, in lieu of this proposal?</strong></p>
<p>NO, there is still the expectation among programmers that constants, const evaluations of constant expressions, are of by default of static storage duration.</p>
<p><strong>Should <code>C++</code> adopt <code>C99</code> literal lifetimes being scoped to the enclosing block instead of to the <code>C++</code> statement, in addition to this proposal?</strong></p>
<p>YES, <code>C99</code> literal lifetimes does not guarantee any reduction in dangling, it just reduces it. This proposal does guarantee but only for const evaluations of constant expressions. Combined their would be an even greater reduction in dangling. As such this proposal and <code>C99</code> compound literals are complimentary. The remainder can be mitigated by other measures.</p>
<p><strong>Should <code>C++</code> adopt <code>C99</code> literal lifetimes being scoped to the enclosing block instead of to the <code>C++</code> statement?</strong></p>
<p>YES, the <code>C++</code> standard is currently telling programmers that the first two examples in the following table are equivalent with respect to the lifetime of the temporary <code>{1, 2}</code> and the named variable <code>cz</code>. This is because the lifetime of the temporary <code>{1, 2}</code> is bound to the statement, which means it is destroyed before <code>some_code_after</code> is called.</p>
<p><strong>Given</strong></p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">any_function</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">complex</span>&amp; cz)</span></span>;</code></pre><table>
<tbody><tr>
<td>
<p><strong>Programmer code</strong></p>
</td>
<td>
<p><strong>What <code>C++</code> is actually doing!</strong></p>
</td>
<td>
<p><strong>Programmer expectation/<code>C99</code></strong></p>
</td>
</tr>
<tr>
<td>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  some_code_before();
  any_function({<span class="hljs-number">1</span>, <span class="hljs-number">2</span>});
  some_code_after();
}</code></pre></td>
<td>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  some_code_before();
  {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">complex</span> anonymous{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>};
    any_function(anonymous);
  }
  some_code_after();
}</code></pre></td>
<td>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  some_code_before();
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">complex</span> anonymous{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>};
  any_function(anonymous);
  some_code_after();
}</code></pre></td>
</tr>
</tbody></table>
<p>This is contrary to general programmer expectations and how it behaves in <code>C99</code>. Besides the fact that a large portion of the <code>C++</code> community has their start in <code>C</code> and besides the fact that no one, in their right mind, would ever write/expand the second example, for every function call that have arguments, their is a more fundamental reason why it is contrary to general programmer expectations. It can actually be impossible to write it that way. Consider another example, now with a return value.</p>
<p><strong>Given</strong></p>
<pre><code class="hljs"><span class="hljs-function">no_default_constructor <span class="hljs-title">any_function</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">complex</span>&amp; cz)</span></span>;</code></pre><table>
<tbody><tr>
<td>
<p><strong>Programmer code</strong></p>
</td>
<td>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  some_code_before();
  no_default_constructor ndc = any_function({<span class="hljs-number">1</span>, <span class="hljs-number">2</span>});
  some_code_after(ndc);
}</code></pre></td>
</tr>
<tr>
<td>
<p><strong>What is <code>C++</code> doing?</strong></p>
</td>
<td>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  some_code_before();
  {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">complex</span> anonymous{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>};
    no_default_constructor ndc = any_function(anonymous);
  }
  some_code_after(ndc);
}</code></pre></td>
</tr>
<tr>
<td>
<p><strong>What is <code>C++</code> doing?</strong></p>
</td>
<td>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  some_code_before();
  no_default_constructor ndc;
  {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">complex</span> anonymous{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>};
    ndc = any_function(anonymous);
  }
  some_code_after(ndc);
}</code></pre></td>
</tr>
</tbody></table>
<p>It should be noted that neither of the "<code>What is C++ doing?</code>" examples even compile. The first because the variable <code>ndc</code> is not accessible to the functional call <code>some_code_after</code>. The second because the class <code>no_default_constructor</code> doesn't have a default constructor and as such does not have a uninitialized state. In short, the current <code>C++</code> behavior of statement scoping of temporaries instead of containing block scoping is more difficult to reason about because the equivalent code cannot be written by the programmer. As such the <code>C99</code> way is simpler, safer and more reasonable.</p>
<p>Regardless, dangling would still be possible, especially for non constant expressions. Those could be fixed by some future, non constant expression proposals.</p>
<p>For instance, stackoverflow has a good example of dangling with <code>Compund literals storage duration in C</code> <sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup>.</p>
<pre><code class="hljs"><span class="hljs-comment">/* Example 2 - if statements with braces */</span>

<span class="hljs-keyword">double</span> *coefficients, value;

<span class="hljs-keyword">if</span>(x){
    coefficients = (<span class="hljs-keyword">double</span>[<span class="hljs-number">3</span>]) {<span class="hljs-number">1.5</span>, <span class="hljs-number">-3.0</span>, <span class="hljs-number">6.0</span>};
}<span class="hljs-keyword">else</span>{
    coefficients = (<span class="hljs-keyword">double</span>[<span class="hljs-number">3</span>]) {<span class="hljs-number">4.5</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">-3.5</span>};
}
value = evaluate_polynomial(coefficients);</code></pre><p>If <code>coefficients</code> was const, as it should be since all control paths lead to constant expressions, than even this example would not dangle with this proposal. While this example is an example of dangling, it is also an example of uninitialized or more specifically delayed initialization. Interestingly, perhaps in the future, the binding block in question could be the block where <code>coefficients</code> is defined, that is the block containing the unitialized variable that is assigned to a constant expression, instead of the block where the uninitialized <code>coefficients</code> is initiated. This refinement to the <code>C</code> and <code>C++</code> rules would fix even more non constexpr dangling in a simple reasonable way.</p>
<p>Once these trivial dangling is removed from the language, the remaining non const dangling could be handled by <code>Bind Returned/Initialized Objects to the Lifetime of Parameters</code> <sup class="footnote-ref"><a href="#fn4" id="fnref4:1">[4:1]</a></sup> or by some similar proposal preferably by fixing it if it makes sense or by a hard error if it really is a decision that the programmer must make.</p>
<h4 id="c-standard"><a class="anchor" href="#c-standard"><span class="octicon octicon-link"></span></a>C++ Standard</h4>
<p>It is also good to consider how the <code>C++</code> standard impacts this proposal and how the standard may be impacted by such a proposal.</p>
<p><code>Working Draft, Standard for Programming Language C++</code> <sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup></p>
<p>String literals are traditionally one of the most common literals and in <code>C++</code> they have static storage duration. This is also the case in many programming languages. As such, these facts leads developers to incorrectly believe that all literals or at least all constant literals have static storage duration.</p>
<p><em>"5.13.5 String literals [lex.string]"</em></p>
<p><em>"9 Evaluating a string-literal results in a string literal object with <strong>static storage duration</strong> (6.7.5). Whether all string-literals are distinct (that is, are stored in nonoverlapping objects) and whether successive evaluations of a string-literal yield the same or a diﬀerent object is unspecifed."</em></p>
<p><em>"[Note 4: <strong>The eﬀect of attempting to modify a string literal object is undefined.</strong> — end note]"</em></p>
<p>This proposal aligns or adjusts literals not only with <code>C</code> compound literals but also with <code>C++</code> string literals. It too should be noted that <code>C++</code> is seemingly anbiguous on whether other literals are like string. Are array literals of <code>static storage duration</code>? What about if the array was of characters?</p>
<!--
If currently unspecifed, this proposal favors making both native and custom literals that are constant expressions into `static storage duration`.
-->
<p><code>C++</code> also says the <em>"eﬀect of attempting to modify a string literal object is undefined."</em> With us having <code>const</code> for so long, there is few reasons for this to go undefined. Undefined behavior doesn't make constants and non constant literals any easier to deal with. A string literal could have <strong>static storage duration</strong> for constant expressions and <strong>automatic storage duration</strong> for <strong>non</strong> constant expressions, just like other literals. The lifetime of the <code>automatic storage duration</code> could be the <code>C</code> rule of the enclosing block since it is safer than <code>C++</code>. This would further increase the consistency between string literals and custom/constexpr literals. However, considering that string literals currently have <code>static storage duration</code> and we want to reduce dangling instead of increasing it by making the lifetime too narrow, it would be reasonable to include rules for uninitialized and general lifetime extension via <code>Bind Returned/Initialized Objects to the Lifetime of Parameters</code> <sup class="footnote-ref"><a href="#fn4" id="fnref4:2">[4:2]</a></sup> before nudging string literals closer to non string literals.</p>
<hr>
<p>The section of the <code>C++</code> standard on temporary objects has an example of dangling.</p>
<p><em>"6.7.7 Temporary objects [class.temporary]"</em></p>
<p><em>"(6.12) — A temporary bound to a reference in a new-initializer (7.6.2.8) persists until the completion of the full-expression containing the new-initializer."</em></p>
<p><em>"[Note 7: This might introduce a dangling reference. — end note]"</em></p>
<p><em>"[Example 5:"</em></p>
<pre><code class="hljs"><span class="hljs-keyword">struct</span> S { <span class="hljs-keyword">int</span> mi; <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&amp; mp; };
S a { <span class="hljs-number">1</span>, {<span class="hljs-number">2</span>,<span class="hljs-number">3</span>} };
S* p = <span class="hljs-keyword">new</span> S{ <span class="hljs-number">1</span>, {<span class="hljs-number">2</span>,<span class="hljs-number">3</span>} }; <span class="hljs-comment">// creates dangling reference</span></code></pre><p><em>"— end example]"</em></p>
<p>It should be noted that this example is not an example of dangling in <code>C99</code> or with my proposal.</p>
<hr>
<p><em>"9.4 Initializers [dcl.init]"</em></p>
<p>Similarly, the section of the <code>C++</code> standard on initializer has multiple examples of dangling.</p>
<p><em>"9.4.1 General [dcl.init.general]"</em></p>
<pre><code class="hljs">A a1{1, f()}; // OK, lifetime is extended
A a2(1, f()); // well-formed, but dangling reference
A a3{1.0, 1}; // error: narrowing conversion
A a4(1.0, 1); // well-formed, but dangling reference
A a5(1.0, std::move(n)); // OK</code></pre><p>Provided that A has a constexpr constuctor and the second parameter was <code>const</code>, with this proposal, <code>a2</code> would not be dangling if f() too was a constant expression. Also <code>a4</code> would also not be dangling. The <code>a4</code> example does not need jumping to the signature of a function to figure out if it is a constant expression as is the case of the <code>a2</code> example. Really the <code>a4</code> example is surprising to current developers that it would be dangling since the native literals 1.0 and 1 can be constant expressions.</p>
<p>It should also be noted that the <code>C++11</code> brace initialization does not or should not create another block scope.</p>
<p><em>"9.4.5 List-initialization [dcl.init.list]"</em></p>
<p>Similarly, the section of the <code>C++</code> standard on list-initialization has an example of dangling.</p>
<pre><code class="hljs"><span class="hljs-keyword">struct</span> A {
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-keyword">int</span>&gt; i4;
A() : i4{ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> } {} <span class="hljs-comment">// ill-formed, would create a dangling reference</span>
};</code></pre><p>According to this proposal, if const was added i4, then this example would neither be ill formed or dangling.</p>
<hr>
<p><em>"11.9.6 Copy/move elision [class.copy.elision]"</em></p>
<p>Similarly, the section of the <code>C++</code> standard on copy and move elision has examples of dangling.</p>
<pre><code class="hljs"><span class="hljs-keyword">constexpr</span> A a; <span class="hljs-comment">// well-formed, a.p points to a</span>
<span class="hljs-keyword">constexpr</span> A b = g(); <span class="hljs-comment">// error: b.p would be dangling (7.7)</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>{
A c = g(); <span class="hljs-comment">// well-formed, c.p can point to c or be dangling</span>
}</code></pre><p>Not only would <code>b</code> no longer dangle but the anbiguity of <code>c.p</code> could "point to c or be dangling" would be gone.</p>
<h4 id="outstanding-issues"><a class="anchor" href="#outstanding-issues"><span class="octicon octicon-link"></span></a>Outstanding Issues</h4>
<h5 id="p1018r16"><a class="anchor" href="#p1018r16"><span class="octicon octicon-link"></span></a>P1018R16</h5>
<p>The <code>C++ Language Evolution status pandemic edition</code> <sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup> list some issues that could be effected positively by this proposal. Many of these have the <code>NAD</code>, Not A Defect, designation. While these may not presently have been a defect, they were surprising enough to have been brought forth in the first place.</p>
<h5 id="lwg2432-initializer_list-assignability"><a class="anchor" href="#lwg2432-initializer_list-assignability"><span class="octicon octicon-link"></span></a>LWG2432 initializer_list assignability</h5>
<pre><code class="hljs"><span class="hljs-keyword">auto</span> il1 = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};

il1 = {<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>}; <span class="hljs-comment">// currently well-formed but dangles immediately; should be ill-formed</span></code></pre><p>With <code>implicit constant initialization</code> and if <code>il1</code> was <code>const auto</code> instead of <code>auto</code>, this example would not dangle and as such should not be ill-formed. With <code>C99</code> literal enclosing block lifetime, this example, AS IS, would not dangle.</p>
<h5 id="cwg900-lifetime-of-temporaries-in-range-based-for"><a class="anchor" href="#cwg900-lifetime-of-temporaries-in-range-based-for"><span class="octicon octicon-link"></span></a>CWG900 Lifetime of temporaries in range-based for</h5>
<pre><code class="hljs"><span class="hljs-comment">// some function</span>

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; foo();

<span class="hljs-comment">// correct usage</span>

<span class="hljs-keyword">auto</span> v = foo();

<span class="hljs-keyword">for</span>( <span class="hljs-keyword">auto</span> i : reverse(v) ) { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; }

<span class="hljs-comment">// problematic usage</span>

<span class="hljs-keyword">for</span>( <span class="hljs-keyword">auto</span> i : reverse(foo()) ) { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; }</code></pre><p>I am not sure what is more shocking. That this is even an issue or that the current resolution is <code>NAD</code>.</p>
<p>With <code>implicit constant initialization</code>, if <code>i</code> was <code>const auto</code> instead of <code>auto</code>, if <code>foo</code> was a <code>constexpr</code> and if <code>reverse</code> was a <code>constexpr</code>, this example would not dangle and as such should not be ill-formed.</p>
<p>With <code>C99</code> literal enclosing block lifetime, this example, AS IS, would not dangle.</p>
<p>In the identifying paper for this issue, <code>Fix the range‐based for loop, Rev1</code> <sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup>, says the following:</p>
<p>"<strong><em>The Root Cause for the problem</em></strong>"</p>
<p>"<em>The reason for the undefined behavior above is that according to the current specification, the range-base
for loop internally is <strong>expanded to multiple statements</strong>:</em>"</p>
<ul>
<li>"<em>First, we have some initializations using the for-range-initializer after the colon and</em>"</li>
<li>"<em>Then, we are calling a low-level for loop</em>"</li>
</ul>
<p>While certainly a factor, the problem is <strong>NOT</strong> that internally, the range-base for loop is expanded to multiple statements. It is rather that one of those statements has a scope of the statement instead of the scope of the containing block. The scoping difference between <code>C99</code> and <code>C++</code> rears it head again. From the programmers perspective, the issue in both cases is that <code>C++</code> doesn't treat temporaries, unnamed variable as if they were named by the programmer just anonymously. The supposed <code>correct usage</code> highlights this fact.</p>
<pre><code class="hljs"><span class="hljs-keyword">auto</span> v = foo();

<span class="hljs-keyword">for</span>( <span class="hljs-keyword">auto</span> i : reverse(v) ) { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; }</code></pre><p>If you just name it, it works! Had <code>reverse(foo())</code> been scoped to the block that contains the range based for loop than this too would have worked.</p>
<table>
<tbody><tr>
<td>
<p><strong>Should have worked</strong></p>
</td>
<td>
<p><strong><code>C99</code> would have worked</strong></p>
</td>
<td>
<p><strong>Programmer made it work</strong></p>
</td>
</tr>
<tr>
<td>
<pre><code class="hljs">{<span class="hljs-comment">// containing block</span>
  <span class="hljs-keyword">for</span>( <span class="hljs-keyword">auto</span> i : reverse(foo()) )
  {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  }
}</code></pre></td>
<td>
<pre><code class="hljs">{<span class="hljs-comment">// containing block</span>
  <span class="hljs-keyword">auto</span>&amp;&amp; rg = reverse(foo());
  <span class="hljs-keyword">auto</span> pos = rg.begin();
  <span class="hljs-keyword">auto</span> end = rg.end();
  <span class="hljs-keyword">for</span> ( ; pos != end; ++pos ) {
    <span class="hljs-keyword">int</span> i = *pos;
    ...
  }
}</code></pre></td>
<td>
<pre><code class="hljs">{<span class="hljs-comment">// containing block</span>
  <span class="hljs-keyword">auto</span> anonymous1 = foo();
  <span class="hljs-keyword">auto</span> anonymous2 = reverse(anonymous1);
  <span class="hljs-keyword">for</span>( <span class="hljs-keyword">auto</span> i : anonymous2 )
  {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  }
}</code></pre></td>
</tr>
</tbody></table>
<p>It should be no different had the programmer broken a compound statement into it's components and named them individually.</p>
<h5 id="cwg1864-list-initialization-of-array-objects"><a class="anchor" href="#cwg1864-list-initialization-of-array-objects"><span class="octicon octicon-link"></span></a>CWG1864 List-initialization of array objects</h5>
<pre><code class="hljs"><span class="hljs-keyword">auto</span> x[] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};</code></pre><p>I am not exactly sure what is the problem here. With <code>implicit constant initialization</code> and if <code>x</code> was <code>const auto</code> instead of <code>auto</code>, this example would not dangle. With <code>C99</code> literal enclosing block lifetime, this example, AS IS, would not dangle.</p>
<h5 id="cwg2111-array-temporaries-in-reference-binding"><a class="anchor" href="#cwg2111-array-temporaries-in-reference-binding"><span class="octicon octicon-link"></span></a>CWG2111 Array temporaries in reference binding</h5>
<p>"<em>Somewhat related to P2174 compound literals.</em>"</p>
<p>That statement and the fact that all of the examples were <code>const</code> constant expressions means that issue is related to this proposal and the <code>NAD</code> may need to be revisited if this proposal ever gets accepted.</p>
<h5 id="cwg914-value-initialization-of-array-types"><a class="anchor" href="#cwg914-value-initialization-of-array-types"><span class="octicon octicon-link"></span></a>CWG914 Value-initialization of array types</h5>
<p>I don't believe this issue is related to or would be benefited from this proposal.</p>
<!--

### Future

There are many paths to reducing dangling via using `static storage duration`. The question that need answering is too what degree do we do it and whether or not we also reduce the gap between `C` and `C++`.

#### Proposal #1: `C++` with `static storage duration`

##### Wording

6.7.7 Temporary objects [class.temporary]

(6.12) — A temporary bound to a reference in a new-initializer (7.6.2.8) persists until the completion of the full-expression containing the new-initializer ++unless the expected type is constant and the temporary possesses a constexpr constructor in which case the temporary is no longer a temporary but rather is of static storage duration++.

NOTE: All examples of dangling need to be revised for not involving constant expressions.

#### Proposal #2: `C compound literals` with `static storage duration`

##### Wording

6.7.7 Temporary objects [class.temporary]

(6.12) — A temporary bound to a reference in a new-initializer (7.6.2.8) persists until the completion of the ++enclosing block of the++ full-expression containing the new-initializer ++unless the expected type is constant and the temporary possesses a constexpr constructor in which case the temporary is no longer a temporary but rather is of static storage duration++.

NOTE: All examples of dangling need to be revised for not involving constant expressions.

#### Optional Addendum #1 - Deduplication

##### Wording

5.13.5 String literals [lex.string]

9 Evaluating a string-literal results in a string literal object with static storage duration (6.7.5). Whether ~~all~~ string-literals ++bound to a character pointer++ are distinct (that is, are stored in nonoverlapping objects) and whether successive evaluations of a string-literal yield the same or a diﬀerent object is unspecifed. ++All successive evaluations of a string-literals bound to a const pointer should yield the same object. Similarly too, all successive evaluations of a custom string-like-literals bound to a const pointer should yield the same object. Further, std::basic_string_view should be stored in overlapping objects.++

[Note 4: The eﬀect of attempting to modify a string literal object is undefned. — end note]

#### Optional Addendum #2 - Undefined Strings

##### Wording

5.13.5 String literals [lex.string]

9 ++Evaluating a string-literal bound to a character pointer results in a string literal object with automatic storage duration (6.7.5).++ Evaluating a string-literal ++bound to a const character pointer++ results in a string literal object with static storage duration (6.7.5). Whether all string-literals are distinct (that is, are stored in nonoverlapping objects) and whether successive evaluations of a string-literal yield the same or a diﬀerent object is unspecifed.

~~[Note 4: The eﬀect of attempting to modify a string literal object is undefined. — end note]~~

#### Optional Addendum #3 - Arrays

Similar wording as for string-literals is needed for native arrays, const std::array, const std::span and initializer lists.

#### Optional Addendum #4 - Address of literal

In order to allow taking the address of a literal, either a new conversion needs adding or the lvalue reference composition rules need revising.

```cpp
f(&(struct foo) { 1,2 });
```

++7.3.16 Lvalue-to-pointer conversion [conv.lval.pointer]++

++1 An lvalue of type T can be converted to a type “pointer to T”.++

++or++

++Taking the explicit address, `&`, of a lvalue reference yields the lvalue reference unless a pointer of compatible type is expected.++

#### Optional Addendum #5 - Delayed Initialization

Assigning a literal to a non const uninitialiated variable results in the lifetime of the literal being the block that contains the declaration of said variable. This one is for that earlier example found on stack overflow.

```cpp
/* Example 2 - if statements with braces */

double *coefficients, value;

if(x){
    coefficients = (double[3]) {1.5, -3.0, 6.0};
}else{
    coefficients = (double[3]) {4.5, 1.0, -3.5};
}
value = evaluate_polynomial(coefficients);
```

-->
<h2 id="summary"><a class="anchor" href="#summary"><span class="octicon octicon-link"></span></a>Summary</h2>
<p>The advantages to <code>C++</code> with this proposal is manifold.</p>
<ul>
<li>Reduce dangling</li>
<li>Make constexpr literals less surprising for new and old developers alike</li>
<li>Reduce the gap between <code>C++</code> and <code>C99</code> compound literals</li>
<li>Improve the potential contribution of <code>C++</code>'s <code>constexpr</code> back to <code>C</code></li>
<li>Make string literals and <code>C++</code> literals more consistent with one another</li>
<li>Reduce undefined behavior</li>
<li>Reduce unitialized errors</li>
<li>Increase and improve upon the utilization of ROM and the benefits that entails</li>
</ul>
<h2 id="frequently-asked-questions"><a class="anchor" href="#frequently-asked-questions"><span class="octicon octicon-link"></span></a>Frequently Asked Questions</h2>
<h3 id="why-not-just-extend-the-lifetime-as-prescribed-in-p0936r0"><a class="anchor" href="#why-not-just-extend-the-lifetime-as-prescribed-in-p0936r0"><span class="octicon octicon-link"></span></a>Why not just extend the lifetime as prescribed in p0936r0?</h3>
<p><code>Bind Returned/Initialized Objects to the Lifetime of Parameters</code> <sup class="footnote-ref"><a href="#fn4" id="fnref4:3">[4:3]</a></sup></p>
<p>In that proposal, a question was raised.</p>
<p><em>"Lifetime Extension or Just a Warning?"</em>
<em>"We could use the marker in two ways:"</em></p>
<ol>
<li><em>"Warn only about some possible buggy behavior."</em></li>
<li><em>"Fix possible buggy behavior by extending the lifetime of temporaries"</em></li>
</ol>
<p>In reality, there are three scenarios; warning, <strong>error</strong> or just fix it by extending the lifetime.</p>
<p>However, things in the real world tend to be more complicated. Depending upon the scenario, at least theoretically some could be fixed, some could be errors and some could be warnings. Further, waiting on a more complicated solution that can fix everything may never happen, so shouldn't we fix what we can, when we can; i.e. low hanging fruit. Also, fixing everything the same way may not even be desirable. Let's consider a real scenario. Extending one's lifetime could mean 2 different things.</p>
<ol>
<li>Change automatic storage duration such that a instances' lifetime is just moved higher up the stack as prescribed in p0936r0.</li>
<li>Change automatic storage duration to static storage duration. [This is what I am proposing but only for those that it logically applies to.]</li>
</ol>
<p>If only #1 was applied holistically via p0936r0, -Wlifetime or some such then that would not be appropriate/reasonable for those that really should be fixed by #2. Likewise #2 can't fix all but MAY make sense for those that it applies to. As such, this proposal and <code>p0936r0</code> <sup class="footnote-ref"><a href="#fn4" id="fnref4:4">[4:4]</a></sup> are complimentary.</p>
<p>Personally, <code>p0936r0</code> <sup class="footnote-ref"><a href="#fn4" id="fnref4:5">[4:5]</a></sup> should be adopted regardless because we give the compiler more information than it had before, that argument(s) lifetime is dependent upon the return(s) lifetime. When we give more information, like we do with const and constexpr, the <code>C++</code> compiler can do amazing things. Any reduction in undefined behavior, dangling references/pointers and delayed/unitialized errors should be welcomed, at least as long it can be explained simply and rationally.</p>
<!--
### Why not just make the evaluation of all constant expressions by default of `static storage duration`?

This too would reduce dangling in the same way as this proposal and has the added benefit of being even simpler rules. [To be decided]
-->
<h3 id="what-about-locality-of-reference"><a class="anchor" href="#what-about-locality-of-reference"><span class="octicon octicon-link"></span></a>What about locality of reference?</h3>
<p>It is true that globals can be slower than locals because they are farther in memory from the code that uses them. So let me clarify, when I say <code>static storage duration</code>, I really mean <strong>logically</strong> <code>static storage duration</code>. If a type has a <code>constexpr</code> copy constructor or is a <code>POD</code> than there is nothing preventing the compiler from copying the global to a local that is closer to the executing code. Rather, the compiler <strong>must</strong> ensure that the code is always available; <strong>effectively</strong> <code>static storage duration</code>.</p>
<p>Consider this from an processor and assembly/machine language standpoint. A processor usually has instructions that works with memory. Whether that memory is ROM or is logically so because it is never written to by a program, then we have constants.</p>
<pre><code class="hljs">mov &lt;<span class="hljs-keyword">register</span>&gt;,&lt;memory&gt;</code></pre><p>A processor may also have specialized versions of common instructions where a constant value is taken as part of the instruction itself. This too is a constant. However, this constant is guaranteed closer to the code because it is physically a part of it.</p>
<pre><code class="hljs">mov &lt;<span class="hljs-keyword">register</span>&gt;,&lt;constant&gt;
mov &lt;memory&gt;,&lt;constant&gt;</code></pre><p>What is more interesting is these two examples of constants have different value categories since the ROM version is addressable and the instruction only version, clearly, is not. It should also be noted that the later unamed/unaddressable version physically can't dangle.</p>
<h2 id="references"><a class="anchor" href="#references"><span class="octicon octicon-link"></span></a>References</h2>
<!-- Constant initialization -->
<!-- Constants (C# Programming Guide) -->
<!-- Value categories -->
<!--Bind Returned/Initialized Objects to the Lifetime of Parameters-->
<!-- String literal -->
<!--Lifetime safety: Preventing common dangling-->
<!--Why lifetime of temporary doesn't extend till lifetime of enclosing object?-->
<!--Making std::string constexpr-->
<!--Making std::vector constexpr-->
<!--Missing constexpr in std::optional and std::variant-->
<!--Making std::unique_ptr constexpr-->
<!--PE Format-->
<!--Class String-->
<!--String.Intern(String) Method-->
<!--String interning-->
<!--A type trait to detect reference binding to temporary-->
<!--The constexpr specifier for object definitions-->
<!--Using constexpr to Improve Security, Performance and Encapsulation in C++-->
<!--Bitesize Modern C++ : constexpr-->
<!--C++ Core Guidelines: Programming at Compile Time with constexpr-->
<!--How can I get GCC to place a C++ constexpr in ROM?-->
<!--Literals for user-defined types-->
<!--Generalized Constant Expressions—Revision 5-->
<!--2021/10/18 Meneide, C Working Draft-->
<!--Working Draft, Standard for Programming Language C++-->
<!--6.28 Compound Literals-->
<!--Compund literals storage duration in C-->
<!--C++ Language Evolution status pandemic edition-->
<!--Fix the range‐based for loop, Rev1-->
<!---->
<!--
[^]: <>
-->
<!--
recipients
std-proposals@lists.isocpp.org
C++ Library Evolution Working Group
lib-ext@lists.isocpp.org
Tomasz Kamiński
tomaszkam@gmail.com
Gašper Ažman
gasper.azman@gmail.com
Tim Song
t.canens.cpp@gmail.com
Alex Gilding (Perforce UK)
Jens Gustedt (INRIA France)
Martin Uecker
Joseph Myers
Bjarne Stroustrup
bjarne@stroustrup.com
Jens Maurer
Jens.Maurer@gmx.net
Gabriel Dos Reis
gdr@microsoft.com
Nicolai Josuttis
nico@josuttis.de
Victor Zverovich
victor.zverovich@gmail.com
Filipe Mulonde
filipemulonde@gmail.com
Arthur O'Dwyer
arthur.j.odwyer@gmail.com
Herb Sutter
hsutter@microsoft.com
-->
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://en.cppreference.com/w/cpp/language/constant_initialization">https://en.cppreference.com/w/cpp/language/constant_initialization</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a> <a href="#fnref1:2" class="footnote-backref">↩︎</a> <a href="#fnref1:3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constants">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constants</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://en.cppreference.com/w/cpp/language/value_category">https://en.cppreference.com/w/cpp/language/value_category</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0936r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0936r0.pdf</a> <a href="#fnref4" class="footnote-backref">↩︎</a> <a href="#fnref4:1" class="footnote-backref">↩︎</a> <a href="#fnref4:2" class="footnote-backref">↩︎</a> <a href="#fnref4:3" class="footnote-backref">↩︎</a> <a href="#fnref4:4" class="footnote-backref">↩︎</a> <a href="#fnref4:5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><a href="https://en.cppreference.com/w/cpp/language/string_literal">https://en.cppreference.com/w/cpp/language/string_literal</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p><a href="https://www.modernescpp.com/index.php/c-core-guidelines-programming-at-compile-time-with-constexpr">https://www.modernescpp.com/index.php/c-core-guidelines-programming-at-compile-time-with-constexpr</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0980r1.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0980r1.pdf</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1004r2.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1004r2.pdf</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2255r2.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2255r2.html</a> <a href="#fnref9" class="footnote-backref">↩︎</a> <a href="#fnref9:1" class="footnote-backref">↩︎</a> <a href="#fnref9:2" class="footnote-backref">↩︎</a> <a href="#fnref9:3" class="footnote-backref">↩︎</a> <a href="#fnref9:4" class="footnote-backref">↩︎</a> <a href="#fnref9:5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2231r1.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2231r1.html</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2231r1.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2231r1.html</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p><a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">https://docs.microsoft.com/en-us/windows/win32/debug/pe-format</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#intern%28%29">https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#intern()</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.string.intern?view=net-6.0">https://docs.microsoft.com/en-us/dotnet/api/system.string.intern?view=net-6.0</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/String_interning">https://en.wikipedia.org/wiki/String_interning</a> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2576r0.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2576r0.html</a> <a href="#fnref16" class="footnote-backref">↩︎</a> <a href="#fnref16:1" class="footnote-backref">↩︎</a> <a href="#fnref16:2" class="footnote-backref">↩︎</a> <a href="#fnref16:3" class="footnote-backref">↩︎</a> <a href="#fnref16:4" class="footnote-backref">↩︎</a> <a href="#fnref16:5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1511.pdf">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1511.pdf</a> <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf</a> <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2731.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2731.pdf</a> <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Compound-Literals.html">https://gcc.gnu.org/onlinedocs/gcc/Compound-Literals.html</a> <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p><a href="https://stackoverflow.com/questions/62776214/compund-literals-storage-duration-in-c">https://stackoverflow.com/questions/62776214/compund-literals-storage-duration-in-c</a> <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4910.pdf">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4910.pdf</a> <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1018r16.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1018r16.html</a> <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2012r1.pdf">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2012r1.pdf</a> <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</article><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.slim.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.2.2/Chart.bundle.min.js"></script><script>$(function() { $('canvas.chartjs').each(function() { new Chart($(this), JSON.parse($(this).text())); }); });</script></body></html>